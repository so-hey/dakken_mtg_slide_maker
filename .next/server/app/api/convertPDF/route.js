(()=>{var e={};e.id=254,e.ids=[254],e.modules={399:e=>{"use strict";e.exports=require("next/dist/compiled/next-server/app-page.runtime.prod.js")},517:e=>{"use strict";e.exports=require("next/dist/compiled/next-server/app-route.runtime.prod.js")},2081:e=>{"use strict";e.exports=require("child_process")},358:e=>{"use strict";e.exports=require("fs")},1017:e=>{"use strict";e.exports=require("path")},2250:(e,t,r)=>{"use strict";let n;r.r(t),r.d(t,{originalPathname:()=>l$,patchFetch:()=>lO,requestAsyncStorage:()=>lx,routeModule:()=>lT,serverHooks:()=>lD,staticGenerationAsyncStorage:()=>lE});var i={};r.r(i),r.d(i,{GET:()=>lS});var o=r(9303),a=r(8716),s=r(670),l=r(7070);function d(e){if("object"!=typeof e||null===e)return!1;let t=Object.getPrototypeOf(e);return(null===t||t===Object.prototype||null===Object.getPrototypeOf(t))&&!(Symbol.toStringTag in e)&&!(Symbol.iterator in e)}let u=require("node:url"),c=(e,t)=>{let r=p(e);if("string"!=typeof r)throw TypeError(`${t} must be a string or a file URL: ${r}.`);return r},p=e=>e instanceof URL?(0,u.fileURLToPath)(e):e,f=(e,t=[],r={})=>{let n=c(e,"First argument"),[i,o]=d(t)?[[],t]:[t,r];if(!Array.isArray(i))throw TypeError(`Second argument must be either an array of arguments or an options object: ${i}`);if(i.some(e=>"object"==typeof e&&null!==e))throw TypeError(`Second argument must be an array of strings: ${i}`);let a=i.map(String),s=a.find(e=>e.includes("\0"));if(void 0!==s)throw TypeError(`Arguments cannot contain null bytes ("\\0"): ${s}`);if(!d(o))throw TypeError(`Last argument must be an options object: ${o}`);return[n,a,o]},h=require("node:child_process"),m=require("node:string_decoder"),{toString:b}=Object.prototype,y=e=>"[object ArrayBuffer]"===b.call(e),g=e=>"[object Uint8Array]"===b.call(e),w=e=>new Uint8Array(e.buffer,e.byteOffset,e.byteLength),v=new TextEncoder,S=e=>v.encode(e),T=new TextDecoder,x=e=>T.decode(e),E=(e,t)=>D(e,t).join(""),D=(e,t)=>{if("utf8"===t&&e.every(e=>"string"==typeof e))return e;let r=new m.StringDecoder(t),n=e.map(e=>"string"==typeof e?S(e):e).map(e=>r.write(e)),i=r.end();return""===i?n:[...n,i]},$=e=>1===e.length&&g(e[0])?e[0]:I(O(e)),O=e=>e.map(e=>"string"==typeof e?S(e):e),I=e=>{let t=new Uint8Array(R(e)),r=0;for(let n of e)t.set(n,r),r+=n.length;return t},R=e=>{let t=0;for(let r of e)t+=r.length;return t},B=e=>Array.isArray(e)&&Array.isArray(e.raw),U=(e,t)=>{let r=[];for(let[n,i]of e.entries())r=L({templates:e,expressions:t,tokens:r,index:n,template:i});if(0===r.length)throw TypeError("Template script must not be empty");let[n,...i]=r;return[n,i,{}]},L=({templates:e,expressions:t,tokens:r,index:n,template:i})=>{if(void 0===i)throw TypeError(`Invalid backslash sequence: ${e.raw[n]}`);let{nextTokens:o,leadingWhitespaces:a,trailingWhitespaces:s}=A(i,e.raw[n]),l=M(r,o,a);if(n===t.length)return l;let d=t[n];return M(l,Array.isArray(d)?d.map(e=>k(e)):[k(d)],s)},A=(e,t)=>{if(0===t.length)return{nextTokens:[],leadingWhitespaces:!1,trailingWhitespaces:!1};let r=[],n=0,i=P.has(t[0]);for(let i=0,o=0;i<e.length;i+=1,o+=1){let a=t[o];if(P.has(a))n!==i&&r.push(e.slice(n,i)),n=i+1;else if("\\"===a){let e=t[o+1];"u"===e&&"{"===t[o+2]?o=t.indexOf("}",o+3):o+=j[e]??1}}let o=n===e.length;return o||r.push(e.slice(n)),{nextTokens:r,leadingWhitespaces:i,trailingWhitespaces:o}},P=new Set([" ","	","\r","\n"]),j={x:3,u:5},M=(e,t,r)=>r||0===e.length||0===t.length?[...e,...t]:[...e.slice(0,-1),`${e.at(-1)}${t[0]}`,...t.slice(1)],k=e=>{let t=typeof e;if("string"===t)return e;if("number"===t)return String(e);if(d(e)&&("stdout"in e||"isMaxBuffer"in e))return N(e);if(e instanceof h.ChildProcess||"[object Promise]"===Object.prototype.toString.call(e))throw TypeError("Unexpected subprocess in template expression. Please use ${await subprocess} instead of ${subprocess}.");throw TypeError(`Unexpected "${t}" in template expression`)},N=({stdout:e})=>{if("string"==typeof e)return e;if(g(e))return x(e);if(void 0===e)throw TypeError('Missing result.stdout in template expression. This is probably due to the previous subprocess\' "stdout" option.');throw TypeError(`Unexpected "${typeof e}" stdout in template expression`)},C=require("node:tty"),G=C.WriteStream.prototype.hasColors(),F=(e,t)=>{if(!G)return e=>e;let r=`\u001B[${e}m`,n=`\u001B[${t}m`;return e=>{let t=e+"",i=t.indexOf(n);if(-1===i)return r+t+n;let o=r,a=0;for(;-1!==i;)o+=t.slice(a,i)+r,a=i+n.length,i=t.indexOf(n,a);return o+(t.slice(a)+n)}};F(0,0);let _=F(1,22);F(2,22),F(3,23),F(4,24),F(53,55),F(7,27),F(8,28),F(9,29),F(30,39),F(31,39),F(32,39),F(33,39),F(34,39),F(35,39),F(36,39),F(37,39);let W=F(90,39);F(40,49),F(41,49),F(42,49),F(43,49),F(44,49),F(45,49),F(46,49),F(47,49),F(100,49);let q=F(91,39);F(92,39);let V=F(93,39);F(94,39),F(95,39),F(96,39),F(97,39),F(101,49),F(102,49),F(103,49),F(104,49),F(105,49),F(106,49),F(107,49);let H=require("node:util"),z=(0,H.debuglog)("execa").enabled?"full":"none",Y=e=>{let t=X(e)?K++:void 0;return Q(e),{verbose:e,verboseId:t}},K=0n,X=e=>e.some(e=>"none"!==e),Q=e=>{for(let t of e){if(!1===t)throw TypeError('The "verbose: false" option was renamed to "verbose: \'none\'".');if(!0===t)throw TypeError('The "verbose: true" option was renamed to "verbose: \'short\'".');if(!Z.has(t)){let e=[...Z].map(e=>`'${e}'`).join(", ");throw TypeError(`The "verbose" option must not be ${t}. Allowed values are: ${e}.`)}}},Z=new Set(["none","short","full"]),J=require("node:fs"),ee=require("node:process"),et={circleQuestionMark:"(?)",questionMarkPrefix:"(?)",square:"█",squareDarkShade:"▓",squareMediumShade:"▒",squareLightShade:"░",squareTop:"▀",squareBottom:"▄",squareLeft:"▌",squareRight:"▐",squareCenter:"■",bullet:"●",dot:"․",ellipsis:"…",pointerSmall:"›",triangleUp:"▲",triangleUpSmall:"▴",triangleDown:"▼",triangleDownSmall:"▾",triangleLeftSmall:"◂",triangleRightSmall:"▸",home:"⌂",heart:"♥",musicNote:"♪",musicNoteBeamed:"♫",arrowUp:"↑",arrowDown:"↓",arrowLeft:"←",arrowRight:"→",arrowLeftRight:"↔",arrowUpDown:"↕",almostEqual:"≈",notEqual:"≠",lessOrEqual:"≤",greaterOrEqual:"≥",identical:"≡",infinity:"∞",subscriptZero:"₀",subscriptOne:"₁",subscriptTwo:"₂",subscriptThree:"₃",subscriptFour:"₄",subscriptFive:"₅",subscriptSix:"₆",subscriptSeven:"₇",subscriptEight:"₈",subscriptNine:"₉",oneHalf:"\xbd",oneThird:"⅓",oneQuarter:"\xbc",oneFifth:"⅕",oneSixth:"⅙",oneEighth:"⅛",twoThirds:"⅔",twoFifths:"⅖",threeQuarters:"\xbe",threeFifths:"⅗",threeEighths:"⅜",fourFifths:"⅘",fiveSixths:"⅚",fiveEighths:"⅝",sevenEighths:"⅞",line:"─",lineBold:"━",lineDouble:"═",lineDashed0:"┄",lineDashed1:"┅",lineDashed2:"┈",lineDashed3:"┉",lineDashed4:"╌",lineDashed5:"╍",lineDashed6:"╴",lineDashed7:"╶",lineDashed8:"╸",lineDashed9:"╺",lineDashed10:"╼",lineDashed11:"╾",lineDashed12:"−",lineDashed13:"–",lineDashed14:"‐",lineDashed15:"⁃",lineVertical:"│",lineVerticalBold:"┃",lineVerticalDouble:"║",lineVerticalDashed0:"┆",lineVerticalDashed1:"┇",lineVerticalDashed2:"┊",lineVerticalDashed3:"┋",lineVerticalDashed4:"╎",lineVerticalDashed5:"╏",lineVerticalDashed6:"╵",lineVerticalDashed7:"╷",lineVerticalDashed8:"╹",lineVerticalDashed9:"╻",lineVerticalDashed10:"╽",lineVerticalDashed11:"╿",lineDownLeft:"┐",lineDownLeftArc:"╮",lineDownBoldLeftBold:"┓",lineDownBoldLeft:"┒",lineDownLeftBold:"┑",lineDownDoubleLeftDouble:"╗",lineDownDoubleLeft:"╖",lineDownLeftDouble:"╕",lineDownRight:"┌",lineDownRightArc:"╭",lineDownBoldRightBold:"┏",lineDownBoldRight:"┎",lineDownRightBold:"┍",lineDownDoubleRightDouble:"╔",lineDownDoubleRight:"╓",lineDownRightDouble:"╒",lineUpLeft:"┘",lineUpLeftArc:"╯",lineUpBoldLeftBold:"┛",lineUpBoldLeft:"┚",lineUpLeftBold:"┙",lineUpDoubleLeftDouble:"╝",lineUpDoubleLeft:"╜",lineUpLeftDouble:"╛",lineUpRight:"└",lineUpRightArc:"╰",lineUpBoldRightBold:"┗",lineUpBoldRight:"┖",lineUpRightBold:"┕",lineUpDoubleRightDouble:"╚",lineUpDoubleRight:"╙",lineUpRightDouble:"╘",lineUpDownLeft:"┤",lineUpBoldDownBoldLeftBold:"┫",lineUpBoldDownBoldLeft:"┨",lineUpDownLeftBold:"┥",lineUpBoldDownLeftBold:"┩",lineUpDownBoldLeftBold:"┪",lineUpDownBoldLeft:"┧",lineUpBoldDownLeft:"┦",lineUpDoubleDownDoubleLeftDouble:"╣",lineUpDoubleDownDoubleLeft:"╢",lineUpDownLeftDouble:"╡",lineUpDownRight:"├",lineUpBoldDownBoldRightBold:"┣",lineUpBoldDownBoldRight:"┠",lineUpDownRightBold:"┝",lineUpBoldDownRightBold:"┡",lineUpDownBoldRightBold:"┢",lineUpDownBoldRight:"┟",lineUpBoldDownRight:"┞",lineUpDoubleDownDoubleRightDouble:"╠",lineUpDoubleDownDoubleRight:"╟",lineUpDownRightDouble:"╞",lineDownLeftRight:"┬",lineDownBoldLeftBoldRightBold:"┳",lineDownLeftBoldRightBold:"┯",lineDownBoldLeftRight:"┰",lineDownBoldLeftBoldRight:"┱",lineDownBoldLeftRightBold:"┲",lineDownLeftRightBold:"┮",lineDownLeftBoldRight:"┭",lineDownDoubleLeftDoubleRightDouble:"╦",lineDownDoubleLeftRight:"╥",lineDownLeftDoubleRightDouble:"╤",lineUpLeftRight:"┴",lineUpBoldLeftBoldRightBold:"┻",lineUpLeftBoldRightBold:"┷",lineUpBoldLeftRight:"┸",lineUpBoldLeftBoldRight:"┹",lineUpBoldLeftRightBold:"┺",lineUpLeftRightBold:"┶",lineUpLeftBoldRight:"┵",lineUpDoubleLeftDoubleRightDouble:"╩",lineUpDoubleLeftRight:"╨",lineUpLeftDoubleRightDouble:"╧",lineUpDownLeftRight:"┼",lineUpBoldDownBoldLeftBoldRightBold:"╋",lineUpDownBoldLeftBoldRightBold:"╈",lineUpBoldDownLeftBoldRightBold:"╇",lineUpBoldDownBoldLeftRightBold:"╊",lineUpBoldDownBoldLeftBoldRight:"╉",lineUpBoldDownLeftRight:"╀",lineUpDownBoldLeftRight:"╁",lineUpDownLeftBoldRight:"┽",lineUpDownLeftRightBold:"┾",lineUpBoldDownBoldLeftRight:"╂",lineUpDownLeftBoldRightBold:"┿",lineUpBoldDownLeftBoldRight:"╃",lineUpBoldDownLeftRightBold:"╄",lineUpDownBoldLeftBoldRight:"╅",lineUpDownBoldLeftRightBold:"╆",lineUpDoubleDownDoubleLeftDoubleRightDouble:"╬",lineUpDoubleDownDoubleLeftRight:"╫",lineUpDownLeftDoubleRightDouble:"╪",lineCross:"╳",lineBackslash:"╲",lineSlash:"╱"},er={tick:"✔",info:"ℹ",warning:"⚠",cross:"✘",squareSmall:"◻",squareSmallFilled:"◼",circle:"◯",circleFilled:"◉",circleDotted:"◌",circleDouble:"◎",circleCircle:"ⓞ",circleCross:"ⓧ",circlePipe:"Ⓘ",radioOn:"◉",radioOff:"◯",checkboxOn:"☒",checkboxOff:"☐",checkboxCircleOn:"ⓧ",checkboxCircleOff:"Ⓘ",pointer:"❯",triangleUpOutline:"△",triangleLeft:"◀",triangleRight:"▶",lozenge:"◆",lozengeOutline:"◇",hamburger:"☰",smiley:"㋡",mustache:"෴",star:"★",play:"▶",nodejs:"⬢",oneSeventh:"⅐",oneNinth:"⅑",oneTenth:"⅒"},en={...et,...er},ei={...et,tick:"√",info:"i",warning:"‼",cross:"\xd7",squareSmall:"□",squareSmallFilled:"■",circle:"( )",circleFilled:"(*)",circleDotted:"( )",circleDouble:"( )",circleCircle:"(○)",circleCross:"(\xd7)",circlePipe:"(│)",radioOn:"(*)",radioOff:"( )",checkboxOn:"[\xd7]",checkboxOff:"[ ]",checkboxCircleOn:"(\xd7)",checkboxCircleOff:"( )",pointer:">",triangleUpOutline:"∆",triangleLeft:"◄",triangleRight:"►",lozenge:"♦",lozengeOutline:"◊",hamburger:"≡",smiley:"☺",mustache:"┌─┐",star:"✶",play:"►",nodejs:"♦",oneSeventh:"1/7",oneNinth:"1/9",oneTenth:"1/10"},eo=("win32"!==ee.platform?"linux"!==ee.env.TERM:ee.env.WT_SESSION||ee.env.TERMINUS_SUBLIME||"{cmd::Cmder}"===ee.env.ConEmuTask||"Terminus-Sublime"===ee.env.TERM_PROGRAM||"vscode"===ee.env.TERM_PROGRAM||"xterm-256color"===ee.env.TERM||"alacritty"===ee.env.TERM||"JetBrains-JediTerm"===ee.env.TERMINAL_EMULATOR)?en:ei;Object.entries(er);let ea=(e,t,r,n)=>{let i=el(e,t,r,n);(0,J.writeFileSync)(es,`${i}
`)},es=2,el=(e,t,r,n)=>e.includes("\n")?e.split("\n").map(e=>ed(e,t,r,n)).join("\n"):ed(e,t,r,n),ed=(e,t,r,n=eu)=>[W(`[${ec()}]`),W(`[${t}]`),n(ef[r]),n(e)].join(" "),eu=e=>e,ec=()=>{let e=new Date;return`${ep(e.getHours(),2)}:${ep(e.getMinutes(),2)}:${ep(e.getSeconds(),2)}.${ep(e.getMilliseconds(),3)}`},ep=(e,t)=>String(e).padStart(t,"0"),ef={command:"$",pipedCommand:"|",output:" ",error:eo.cross,warning:eo.warning,success:eo.tick},eh=(e,{verbose:t,verboseId:r},{piped:n=!1})=>{X(t)&&ea(e,r,n?"pipedCommand":"command",_)},em=()=>ee.hrtime.bigint(),eb=e=>Number(ee.hrtime.bigint()-e)/1e6,ey=(e,t)=>{let r=[e,...t];return{command:r.join(" "),escapedCommand:r.map(e=>eE(ew(e))).join(" ")}},eg=e=>(0,H.stripVTControlCharacters)(e).split("\n").map(e=>ew(e)).join("\n"),ew=e=>e.replaceAll(eS,e=>ev(e)),ev=e=>{let t=eT[e];if(void 0!==t)return t;let r=e.codePointAt(0),n=r.toString(16);return r<=ex?`\\u${n.padStart(4,"0")}`:`\\U${n}`},eS=/\p{Separator}|\p{Other}/gu,eT={" ":" ","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","	":"\\t"},ex=65535,eE=e=>eD.test(e)?e:"win32"===ee.platform?`"${e.replaceAll('"','""')}"`:`'${e.replaceAll("'","'\\''")}'`,eD=/^[\w./-]+$/,e$=e=>eO.includes(e),eO=[ee.stdin,ee.stdout,ee.stderr],eI=["stdin","stdout","stderr"],eR=e=>eI[e]??`stdio[${e}]`,eB=e=>{let t={...e};for(let r of e_)t[r]=eU(e,r);return t},eU=(e,t)=>{let r=Array.from({length:eL(e)});return eG(eA(e[t],r,t),t)},eL=({stdio:e})=>Array.isArray(e)?Math.max(e.length,eI.length):eI.length,eA=(e,t,r)=>d(e)?eP(e,t,r):t.fill(e),eP=(e,t,r)=>{for(let n of Object.keys(e).sort(ej))for(let i of ek(n,r,t))t[i]=e[n];return t},ej=(e,t)=>eM(e)<eM(t)?1:-1,eM=e=>"stdout"===e||"stderr"===e?0:"all"===e?2:1,ek=(e,t,r)=>{let n=eN(e);if(void 0===n||0===n)throw TypeError(`"${t}.${e}" is invalid.
It must be "${t}.stdout", "${t}.stderr", "${t}.all", or "${t}.fd3", "${t}.fd4" (and so on).`);if(n>=r.length)throw TypeError(`"${t}.${e}" is invalid: that file descriptor does not exist.
Please set the "stdio" option to ensure that file descriptor exists.`);return"all"===n?[1,2]:[n]},eN=e=>{if("all"===e)return e;if(eI.includes(e))return eI.indexOf(e);let t=eC.exec(e);if(null!==t)return Number(t[1])},eC=/^fd(\d+)$/,eG=(e,t)=>e.map(e=>void 0===e?eF[t]:e),eF={lines:!1,buffer:!0,maxBuffer:1e8,verbose:z,stripFinalNewline:!0},e_=["lines","buffer","maxBuffer","verbose","stripFinalNewline"],eW=(e,t,r)=>{let n=em(),{command:i,escapedCommand:o}=ey(e,t),a=Y(eU(r,"verbose"));return eh(o,a,r),{command:i,escapedCommand:o,startTime:n,verboseInfo:a}},eq=require("node:path");var eV=r(6916);function eH(e={}){let{env:t=process.env,platform:r=process.platform}=e;return"win32"!==r?"PATH":Object.keys(t).reverse().find(e=>"PATH"===e.toUpperCase())||"Path"}let ez=({cwd:e=ee.cwd(),path:t=ee.env[eH()],preferLocal:r=!0,execPath:n=ee.execPath,addExecPath:i=!0}={})=>{let o=e instanceof URL?(0,u.fileURLToPath)(e):e,a=eq.resolve(o),s=[];return r&&eY(s,a),i&&eK(s,n,a),[...s,t].join(eq.delimiter)},eY=(e,t)=>{let r;for(;r!==t;)e.push(eq.join(t,"node_modules/.bin")),r=t,t=eq.resolve(t,"..")},eK=(e,t,r)=>{let n=t instanceof URL?(0,u.fileURLToPath)(t):t;e.push(eq.resolve(r,n,".."))},eX=({env:e=ee.env,...t}={})=>{let r=eH({env:e={...e}});return t.path=e[r],e[r]=ez(t),e},eQ=require("node:timers/promises"),eZ=(e,t,r)=>new(r?e8:e4)(t,e instanceof eJ?{}:{cause:e});class eJ extends Error{}let e0=(e,t)=>{Object.defineProperty(e.prototype,"name",{value:t,writable:!0,enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,e2,{value:!0,writable:!1,enumerable:!1,configurable:!1})},e1=e=>e3(e)&&e2 in e,e2=Symbol("isExecaError"),e3=e=>"[object Error]"===Object.prototype.toString.call(e);class e4 extends Error{}e0(e4,e4.name);class e8 extends Error{}e0(e8,e8.name);let e9=require("node:os"),e6=e=>{let t="option `killSignal`";if(0===e)throw TypeError(`Invalid ${t}: 0 cannot be used.`);return e5(e,t)},e7=e=>0===e?e:e5(e,"`subprocess.kill()`'s argument"),e5=(e,t)=>{if(Number.isInteger(e))return te(e,t);if("string"==typeof e)return tr(e,t);throw TypeError(`Invalid ${t} ${String(e)}: it must be a string or an integer.
${tn()}`)},te=(e,t)=>{if(tt.has(e))return tt.get(e);throw TypeError(`Invalid ${t} ${e}: this signal integer does not exist.
${tn()}`)},tt=new Map(Object.entries(e9.constants.signals).reverse().map(([e,t])=>[t,e])),tr=(e,t)=>{if(e in e9.constants.signals)return e;if(e.toUpperCase() in e9.constants.signals)throw TypeError(`Invalid ${t} '${e}': please rename it to '${e.toUpperCase()}'.`);throw TypeError(`Invalid ${t} '${e}': this signal name does not exist.
${tn()}`)},tn=()=>`Available signal names: ${ti()}.
Available signal numbers: ${to()}.`,ti=()=>Object.keys(e9.constants.signals).sort().map(e=>`'${e}'`).join(", "),to=()=>[...new Set(Object.values(e9.constants.signals).sort((e,t)=>e-t))].join(", "),ta=e=>{if(!1===e)return e;if(!0===e)return ts;if(!Number.isFinite(e)||e<0)throw TypeError(`Expected the \`forceKillAfterDelay\` option to be a non-negative integer, got \`${e}\` (${typeof e})`);return e},ts=5e3,tl=({kill:e,options:{forceKillAfterDelay:t,killSignal:r},onInternalError:n,controller:i},o,a)=>{let{signal:s,error:l}=td(o,a,r);tu(l,n);let d=e(s);return tc({kill:e,signal:s,forceKillAfterDelay:t,killSignal:r,killResult:d,controller:i}),d},td=(e,t,r)=>{let[n=r,i]=e3(e)?[void 0,e]:[e,t];if("string"!=typeof n&&!Number.isInteger(n))throw TypeError(`The first argument must be an error instance or a signal name string/integer: ${String(n)}`);if(void 0!==i&&!e3(i))throw TypeError(`The second argument is optional. If specified, it must be an error instance: ${i}`);return{signal:e7(n),error:i}},tu=(e,t)=>{void 0!==e&&t.reject(e)},tc=async({kill:e,signal:t,forceKillAfterDelay:r,killSignal:n,killResult:i,controller:o})=>{if(tp(t,r,n,i))try{await (0,eQ.setTimeout)(r,void 0,{signal:o.signal}),e("SIGKILL")}catch{}},tp=(e,t,r,n)=>e===r&&!1!==t&&n,tf=({timeout:e})=>{if(void 0!==e&&(!Number.isFinite(e)||e<0))throw TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${e}\` (${typeof e})`)},th=(e,t,r,n)=>0===t||void 0===t?[]:[tm(e,t,r,n)],tm=async(e,t,r,{signal:n})=>{throw await (0,eQ.setTimeout)(t,void 0,{signal:n}),r.timedOut=!0,e.kill(),new eJ},tb=(e,t,{node:r=!1,nodePath:n=ee.execPath,nodeOptions:i=ee.execArgv.filter(e=>!e.startsWith("--inspect")),cwd:o,execPath:a,...s})=>{if(void 0!==a)throw TypeError('The "execPath" option has been removed. Please use the "nodePath" option instead.');let l=c(n,'The "nodePath" option'),d=(0,eq.resolve)(o,l),u={...s,nodePath:d,node:r,cwd:o};if(!r)return[e,t,u];if("node"===(0,eq.basename)(e,".exe"))throw TypeError('When the "node" option is true, the first argument does not need to be "node".');return[d,[...i,e,...t],{ipc:!0,...u,shell:!1}]},ty=({encoding:e})=>{if(tv.has(e))return;let t=tS(e);if(void 0!==t)throw TypeError(`Invalid option \`encoding: ${tx(e)}\`.
Please rename it to ${tx(t)}.`);let r=[...tv].map(e=>tx(e)).join(", ");throw TypeError(`Invalid option \`encoding: ${tx(e)}\`.
Please rename it to one of: ${r}.`)},tg=new Set(["utf8","utf16le"]),tw=new Set(["buffer","hex","base64","base64url","latin1","ascii"]),tv=new Set([...tg,...tw]),tS=e=>{if(null===e)return"buffer";if("string"!=typeof e)return;let t=e.toLowerCase();return t in tT?tT[t]:tv.has(t)?t:void 0},tT={"utf-8":"utf8","utf-16le":"utf16le","ucs-2":"utf16le",ucs2:"utf16le",binary:"latin1"},tx=e=>"string"==typeof e?`"${e}"`:String(e),tE=(e=tD())=>{let t=c(e,'The "cwd" option');return(0,eq.resolve)(t)},tD=()=>{try{return ee.cwd()}catch(e){throw e.message=`The current directory does not exist.
${e.message}`,e}},t$=(e,t)=>{let r;if(t===tD())return e;try{r=(0,J.statSync)(t)}catch(r){return`The "cwd" option is invalid: ${t}.
${r.message}
${e}`}return r.isDirectory()?e:`The "cwd" option is not a directory: ${t}.
${e}`},tO=(e,t,r)=>{r.cwd=tE(r.cwd);let[n,i,o]=tb(e,t,r),{command:a,args:s,options:l}=eV._parse(n,i,o),d=tI(eB(l));return tf(d),ty(d),d.shell=p(d.shell),d.env=tR(d),d.killSignal=e6(d.killSignal),d.forceKillAfterDelay=ta(d.forceKillAfterDelay),d.lines=d.lines.map((e,t)=>e&&!tw.has(d.encoding)&&d.buffer[t]),"win32"===ee.platform&&"cmd"===(0,eq.basename)(a,".exe")&&s.unshift("/q"),{file:a,commandArguments:s,options:d}},tI=({extendEnv:e=!0,preferLocal:t=!1,cwd:r,localDir:n=r,encoding:i="utf8",reject:o=!0,cleanup:a=!0,all:s=!1,windowsHide:l=!0,killSignal:d="SIGTERM",forceKillAfterDelay:u=!0,ipc:c=!1,serialization:p="advanced",...f})=>({...f,extendEnv:e,preferLocal:t,cwd:r,localDirectory:n,encoding:i,reject:o,cleanup:a,all:s,windowsHide:l,killSignal:d,forceKillAfterDelay:u,ipc:c,serialization:p}),tR=({env:e,extendEnv:t,preferLocal:r,node:n,localDirectory:i,nodePath:o})=>{let a=t?{...ee.env,...e}:e;return r||n?eX({env:a,cwd:i,execPath:o,preferLocal:r,addExecPath:n}):a},tB=()=>Array.from({length:tA-tL+1},tU),tU=(e,t)=>({name:`SIGRT${t+1}`,number:tL+t,action:"terminate",description:"Application-specific signal (realtime)",standard:"posix"}),tL=34,tA=64,tP=[{name:"SIGHUP",number:1,action:"terminate",description:"Terminal closed",standard:"posix"},{name:"SIGINT",number:2,action:"terminate",description:"User interruption with CTRL-C",standard:"ansi"},{name:"SIGQUIT",number:3,action:"core",description:"User interruption with CTRL-\\",standard:"posix"},{name:"SIGILL",number:4,action:"core",description:"Invalid machine instruction",standard:"ansi"},{name:"SIGTRAP",number:5,action:"core",description:"Debugger breakpoint",standard:"posix"},{name:"SIGABRT",number:6,action:"core",description:"Aborted",standard:"ansi"},{name:"SIGIOT",number:6,action:"core",description:"Aborted",standard:"bsd"},{name:"SIGBUS",number:7,action:"core",description:"Bus error due to misaligned, non-existing address or paging error",standard:"bsd"},{name:"SIGEMT",number:7,action:"terminate",description:"Command should be emulated but is not implemented",standard:"other"},{name:"SIGFPE",number:8,action:"core",description:"Floating point arithmetic error",standard:"ansi"},{name:"SIGKILL",number:9,action:"terminate",description:"Forced termination",standard:"posix",forced:!0},{name:"SIGUSR1",number:10,action:"terminate",description:"Application-specific signal",standard:"posix"},{name:"SIGSEGV",number:11,action:"core",description:"Segmentation fault",standard:"ansi"},{name:"SIGUSR2",number:12,action:"terminate",description:"Application-specific signal",standard:"posix"},{name:"SIGPIPE",number:13,action:"terminate",description:"Broken pipe or socket",standard:"posix"},{name:"SIGALRM",number:14,action:"terminate",description:"Timeout or timer",standard:"posix"},{name:"SIGTERM",number:15,action:"terminate",description:"Termination",standard:"ansi"},{name:"SIGSTKFLT",number:16,action:"terminate",description:"Stack is empty or overflowed",standard:"other"},{name:"SIGCHLD",number:17,action:"ignore",description:"Child process terminated, paused or unpaused",standard:"posix"},{name:"SIGCLD",number:17,action:"ignore",description:"Child process terminated, paused or unpaused",standard:"other"},{name:"SIGCONT",number:18,action:"unpause",description:"Unpaused",standard:"posix",forced:!0},{name:"SIGSTOP",number:19,action:"pause",description:"Paused",standard:"posix",forced:!0},{name:"SIGTSTP",number:20,action:"pause",description:'Paused using CTRL-Z or "suspend"',standard:"posix"},{name:"SIGTTIN",number:21,action:"pause",description:"Background process cannot read terminal input",standard:"posix"},{name:"SIGBREAK",number:21,action:"terminate",description:"User interruption with CTRL-BREAK",standard:"other"},{name:"SIGTTOU",number:22,action:"pause",description:"Background process cannot write to terminal output",standard:"posix"},{name:"SIGURG",number:23,action:"ignore",description:"Socket received out-of-band data",standard:"bsd"},{name:"SIGXCPU",number:24,action:"core",description:"Process timed out",standard:"bsd"},{name:"SIGXFSZ",number:25,action:"core",description:"File too big",standard:"bsd"},{name:"SIGVTALRM",number:26,action:"terminate",description:"Timeout or timer",standard:"bsd"},{name:"SIGPROF",number:27,action:"terminate",description:"Timeout or timer",standard:"bsd"},{name:"SIGWINCH",number:28,action:"ignore",description:"Terminal window size changed",standard:"bsd"},{name:"SIGIO",number:29,action:"terminate",description:"I/O is available",standard:"other"},{name:"SIGPOLL",number:29,action:"terminate",description:"Watched event",standard:"other"},{name:"SIGINFO",number:29,action:"ignore",description:"Request for process information",standard:"other"},{name:"SIGPWR",number:30,action:"terminate",description:"Device running out of power",standard:"systemv"},{name:"SIGSYS",number:31,action:"core",description:"Invalid system call",standard:"other"},{name:"SIGUNUSED",number:31,action:"terminate",description:"Invalid system call",standard:"other"}],tj=()=>[...tP,...tB()].map(tM),tM=({name:e,number:t,description:r,action:n,forced:i=!1,standard:o})=>{let{signals:{[e]:a}}=e9.constants,s=void 0!==a;return{name:e,number:s?a:t,description:r,supported:s,action:n,forced:i,standard:o}},tk=Object.fromEntries(tj().map(({name:e,number:t,description:r,supported:n,action:i,forced:o,standard:a})=>[e,{name:e,number:t,description:r,supported:n,action:i,forced:o,standard:a}])),tN=(e,t)=>{let r=tC(e,t);if(void 0===r)return{};let{name:n,description:i,supported:o,action:a,forced:s,standard:l}=r;return{[e]:{name:n,number:e,description:i,supported:o,action:a,forced:s,standard:l}}},tC=(e,t)=>{let r=t.find(({name:t})=>e9.constants.signals[t]===e);return void 0!==r?r:t.find(t=>t.number===e)};function tG(e){if("string"==typeof e)return tF(e);if(!(ArrayBuffer.isView(e)&&1===e.BYTES_PER_ELEMENT))throw Error("Input must be a string or a Uint8Array");return t_(e)}(()=>{let e=tj();return Object.assign({},...Array.from({length:tA+1},(t,r)=>tN(r,e)))})();let tF=e=>e.at(-1)===tW?e.slice(0,e.at(-2)===tV?-2:-1):e,t_=e=>e.at(-1)===tq?e.subarray(0,e.at(-2)===tH?-2:-1):e,tW="\n",tq=tW.codePointAt(0),tV="\r",tH=tV.codePointAt(0);function tz(e,{checkOpen:t=!0}={}){return null!==e&&"object"==typeof e&&(e.writable||e.readable||!t||void 0===e.writable&&void 0===e.readable)&&"function"==typeof e.pipe}function tY(e,{checkOpen:t=!0}={}){return tz(e,{checkOpen:t})&&(e.writable||!t)&&"function"==typeof e.write&&"function"==typeof e.end&&"boolean"==typeof e.writable&&"boolean"==typeof e.writableObjectMode&&"function"==typeof e.destroy&&"boolean"==typeof e.destroyed}function tK(e,{checkOpen:t=!0}={}){return tz(e,{checkOpen:t})&&(e.readable||!t)&&"function"==typeof e.read&&"boolean"==typeof e.readable&&"boolean"==typeof e.readableObjectMode&&"function"==typeof e.destroy&&"boolean"==typeof e.destroyed}function tX(e,t){return tY(e,t)&&tK(e,t)}let tQ=Object.getPrototypeOf(Object.getPrototypeOf(async function*(){}).prototype);class tZ{#e;#t;#r=!1;#n=void 0;constructor(e,t){this.#e=e,this.#t=t}next(){let e=()=>this.#i();return this.#n=this.#n?this.#n.then(e,e):e(),this.#n}return(e){let t=()=>this.#o(e);return this.#n?this.#n.then(t,t):t()}async #i(){let e;if(this.#r)return{done:!0,value:void 0};try{e=await this.#e.read()}catch(e){throw this.#n=void 0,this.#r=!0,this.#e.releaseLock(),e}return e.done&&(this.#n=void 0,this.#r=!0,this.#e.releaseLock()),e}async #o(e){if(this.#r)return{done:!0,value:e};if(this.#r=!0,!this.#t){let t=this.#e.cancel(e);return this.#e.releaseLock(),await t,{done:!0,value:e}}return this.#e.releaseLock(),{done:!0,value:e}}}let tJ=Symbol();function t0(){return this[tJ].next()}function t1(e){return this[tJ].return(e)}Object.defineProperty(t0,"name",{value:"next"}),Object.defineProperty(t1,"name",{value:"return"});let t2=Object.create(tQ,{next:{enumerable:!0,configurable:!0,writable:!0,value:t0},return:{enumerable:!0,configurable:!0,writable:!0,value:t1}});function t3({preventCancel:e=!1}={}){let t=new tZ(this.getReader(),e),r=Object.create(t2);return r[tJ]=t,r}let t4=e=>{if(tK(e,{checkOpen:!1})&&void 0!==t7.on)return t9(e);if("function"==typeof e?.[Symbol.asyncIterator])return e;if("[object ReadableStream]"===t8.call(e))return t3.call(e);throw TypeError("The first argument must be a Readable, a ReadableStream, or an async iterable.")},{toString:t8}=Object.prototype,t9=async function*(e){let t=new AbortController,r={};t6(e,t,r);try{for await(let[r]of t7.on(e,"data",{signal:t.signal}))yield r}catch(e){if(void 0!==r.error)throw r.error;if(!t.signal.aborted)throw e}finally{e.destroy()}},t6=async(e,t,r)=>{try{await t7.finished(e,{cleanup:!0,readable:!0,writable:!1,error:!1})}catch(e){r.error=e}finally{t.abort()}},t7={},t5=async(e,{init:t,convertChunk:r,getSize:n,truncateChunk:i,addChunk:o,getFinalChunk:a,finalize:s},{maxBuffer:l=Number.POSITIVE_INFINITY}={})=>{let d=t4(e),u=t();u.length=0;try{for await(let e of d){let t=r[rn(e)](e,u);rt({convertedChunk:t,state:u,getSize:n,truncateChunk:i,addChunk:o,maxBuffer:l})}return re({state:u,convertChunk:r,getSize:n,truncateChunk:i,addChunk:o,getFinalChunk:a,maxBuffer:l}),s(u)}catch(t){let e="object"==typeof t&&null!==t?t:Error(t);throw e.bufferedData=s(u),e}},re=({state:e,getSize:t,truncateChunk:r,addChunk:n,getFinalChunk:i,maxBuffer:o})=>{let a=i(e);void 0!==a&&rt({convertedChunk:a,state:e,getSize:t,truncateChunk:r,addChunk:n,maxBuffer:o})},rt=({convertedChunk:e,state:t,getSize:r,truncateChunk:n,addChunk:i,maxBuffer:o})=>{let a=r(e),s=t.length+a;if(s<=o){rr(e,t,i,s);return}let l=n(e,o-t.length);throw void 0!==l&&rr(l,t,i,o),new ro},rr=(e,t,r,n)=>{t.contents=r(e,t,n),t.length=n},rn=e=>{let t=typeof e;if("string"===t)return"string";if("object"!==t||null===e)return"others";if(globalThis.Buffer?.isBuffer(e))return"buffer";let r=ri.call(e);return"[object ArrayBuffer]"===r?"arrayBuffer":"[object DataView]"===r?"dataView":Number.isInteger(e.byteLength)&&Number.isInteger(e.byteOffset)&&"[object ArrayBuffer]"===ri.call(e.buffer)?"typedArray":"others"},{toString:ri}=Object.prototype;class ro extends Error{name="MaxBufferError";constructor(){super("maxBuffer exceeded")}}let ra=({error:e,stream:t,readableObjectMode:r,lines:n,encoding:i,fdNumber:o})=>{if(!(e instanceof ro))throw e;if("all"===o)return e;let a=rs(r,n,i);throw e.maxBufferInfo={fdNumber:o,unit:a},t.destroy(),e},rs=(e,t,r)=>e?"objects":t?"lines":"buffer"===r?"bytes":"characters",rl=(e,t)=>{let{streamName:r,threshold:n,unit:i}=rd(e,t);return`Command's ${r} was larger than ${n} ${i}`},rd=(e,t)=>{if(e?.maxBufferInfo===void 0)return{streamName:"output",threshold:t[1],unit:"bytes"};let{maxBufferInfo:{fdNumber:r,unit:n}}=e;return delete e.maxBufferInfo,{streamName:eR(r),threshold:t[r],unit:n}},ru=(e,t,r)=>e?.code==="ENOBUFS"&&null!==t&&t.some(e=>null!==e&&e.length>rp(r)),rc=(e,t,r)=>{if(!t)return e;let n=rp(r);return e.length>n?e.slice(0,n):e},rp=([,e])=>e,rf=({stdio:e,all:t,originalError:r,signal:n,signalDescription:i,exitCode:o,escapedCommand:a,timedOut:s,isCanceled:l,isMaxBuffer:d,maxBuffer:u,timeout:c,cwd:p})=>{let f=r?.code,h=rh({originalError:r,timedOut:s,timeout:c,isMaxBuffer:d,maxBuffer:u,errorCode:f,signal:n,signalDescription:i,exitCode:o,isCanceled:l}),m=rm(r,p),b=void 0===m?"":`
${m}`,y=`${h}: ${a}${b}`,g=[y,...void 0===t?[e[2],e[1]]:[t],...e.slice(3)].map(e=>eg(tG(rb(e)))).filter(Boolean).join("\n\n");return{originalMessage:m,shortMessage:y,message:g}},rh=({originalError:e,timedOut:t,timeout:r,isMaxBuffer:n,maxBuffer:i,errorCode:o,signal:a,signalDescription:s,exitCode:l,isCanceled:d})=>t?`Command timed out after ${r} milliseconds`:d?"Command was canceled":n?rl(e,i):void 0!==o?`Command failed with ${o}`:void 0!==a?`Command was killed with ${a} (${s})`:void 0!==l?`Command failed with exit code ${l}`:"Command failed",rm=(e,t)=>{if(e instanceof eJ)return;let r=eg(t$(e1(e)?e.originalMessage:String(e?.message??e),t));return""===r?void 0:r},rb=e=>Array.isArray(e)?e.map(e=>tG(ry(e))).filter(Boolean).join("\n"):ry(e),ry=e=>"string"==typeof e?e:g(e)?x(e):"",rg=({command:e,escapedCommand:t,stdio:r,all:n,options:{cwd:i},startTime:o})=>rT({command:e,escapedCommand:t,cwd:i,durationMs:eb(o),failed:!1,timedOut:!1,isCanceled:!1,isTerminated:!1,isMaxBuffer:!1,exitCode:0,stdout:r[1],stderr:r[2],all:n,stdio:r,pipedFrom:[]}),rw=({error:e,command:t,escapedCommand:r,fileDescriptors:n,options:i,startTime:o,isSync:a})=>rv({error:e,command:t,escapedCommand:r,startTime:o,timedOut:!1,isCanceled:!1,isMaxBuffer:!1,stdio:Array.from({length:n.length}),options:i,isSync:a}),rv=({error:e,command:t,escapedCommand:r,startTime:n,timedOut:i,isCanceled:o,isMaxBuffer:a,exitCode:s,signal:l,stdio:d,all:u,options:{timeoutDuration:c,timeout:p=c,cwd:f,maxBuffer:h},isSync:m})=>{let{exitCode:b,signal:y,signalDescription:g}=rx(s,l),{originalMessage:w,shortMessage:v,message:S}=rf({stdio:d,all:u,originalError:e,signal:y,signalDescription:g,exitCode:b,escapedCommand:r,timedOut:i,isCanceled:o,isMaxBuffer:a,maxBuffer:h,timeout:p,cwd:f}),T=eZ(e,S,m);return Object.assign(T,rS({error:T,command:t,escapedCommand:r,startTime:n,timedOut:i,isCanceled:o,isMaxBuffer:a,exitCode:b,signal:y,signalDescription:g,stdio:d,all:u,cwd:f,originalMessage:w,shortMessage:v})),T},rS=({error:e,command:t,escapedCommand:r,startTime:n,timedOut:i,isCanceled:o,isMaxBuffer:a,exitCode:s,signal:l,signalDescription:d,stdio:u,all:c,cwd:p,originalMessage:f,shortMessage:h})=>rT({shortMessage:h,originalMessage:f,command:t,escapedCommand:r,cwd:p,durationMs:eb(n),failed:!0,timedOut:i,isCanceled:o,isTerminated:void 0!==l,isMaxBuffer:a,exitCode:s,signal:l,signalDescription:d,code:e.cause?.code,stdout:u[1],stderr:u[2],all:c,stdio:u,pipedFrom:[]}),rT=e=>Object.fromEntries(Object.entries(e).filter(([,e])=>void 0!==e)),rx=(e,t)=>{let r=null===t?void 0:t,n=void 0===r?void 0:tk[t].description;return{exitCode:null===e?void 0:e,signal:r,signalDescription:n}},rE=e=>Number.isFinite(e)?e:0,rD=e=>0===e||0n===e,r$=(e,t)=>1===t||1n===t?e:`${e}s`,rO=24n*60n*60n*1000n,rI=({message:e,failed:t,reject:r,verboseId:n,icon:i})=>{t&&ea(e,n,i,r?q:V)},rR=({shortMessage:e,failed:t,durationMs:r},n,i)=>{rU({message:e,failed:t,reject:n,durationMs:r,verboseInfo:i})},rB=(e,t,r)=>{rU({message:eg(String(e)),failed:!0,reject:!0,durationMs:eb(t),verboseInfo:r})},rU=({message:e,failed:t,reject:r,durationMs:n,verboseInfo:{verbose:i,verboseId:o}})=>{if(!X(i))return;let a=rA(t,r);rI({message:e,failed:t,reject:r,verboseId:o,icon:a}),rL(n,o,a)},rL=(e,t,r)=>{ea(`(done in ${function(e,t){let r="bigint"==typeof e;if(!r&&!Number.isFinite(e))throw TypeError("Expected a finite number or bigint");(t={...t}).colonNotation&&(t.compact=!1,t.formatSubMilliseconds=!1,t.separateMilliseconds=!1,t.verbose=!1),t.compact&&(t.unitCount=1,t.secondsDecimalDigits=0,t.millisecondsDecimalDigits=0);let n=[],i=(e,r,i,o)=>{if(!((0===n.length||!t.colonNotation)&&rD(e))||t.colonNotation&&"m"===i){if(o=o??String(e),t.colonNotation){let e=o.includes(".")?o.split(".")[0].length:o.length,t=n.length>0?2:1;o="0".repeat(Math.max(0,t-e))+o}else o+=t.verbose?" "+r$(r,e):i;n.push(o)}},o=function(e){switch(typeof e){case"number":if(Number.isFinite(e))return{days:Math.trunc(e/864e5),hours:Math.trunc(e/36e5%24),minutes:Math.trunc(e/6e4%60),seconds:Math.trunc(e/1e3%60),milliseconds:Math.trunc(e%1e3),microseconds:Math.trunc(rE(1e3*e)%1e3),nanoseconds:Math.trunc(rE(1e6*e)%1e3)};break;case"bigint":return{days:e/86400000n,hours:e/3600000n%24n,minutes:e/60000n%60n,seconds:e/1000n%60n,milliseconds:e%1000n,microseconds:0n,nanoseconds:0n}}throw TypeError("Expected a finite number or bigint")}(e),a=BigInt(o.days);if(i(a/365n,"year","y"),i(a%365n,"day","d"),i(Number(o.hours),"hour","h"),i(Number(o.minutes),"minute","m"),t.separateMilliseconds||t.formatSubMilliseconds||!t.colonNotation&&e<1e3){let e=Number(o.seconds),r=Number(o.milliseconds),n=Number(o.microseconds),a=Number(o.nanoseconds);if(i(e,"second","s"),t.formatSubMilliseconds)i(r,"millisecond","ms"),i(n,"microsecond","\xb5s"),i(a,"nanosecond","ns");else{let e=r+n/1e3+a/1e6,o="number"==typeof t.millisecondsDecimalDigits?t.millisecondsDecimalDigits:0,s=o?e.toFixed(o):e>=1?Math.round(e):Math.ceil(e);i(Number.parseFloat(s),"millisecond","ms",s)}}else{var s;let n=(Math.round(Math.floor((r?Number(e%rO):e)/1e3%60*10**(s="number"==typeof t.secondsDecimalDigits?t.secondsDecimalDigits:1)+1e-7))/10**s).toFixed(s),o=t.keepDecimalsOnWholeSeconds?n:n.replace(/\.0+$/,"");i(Number.parseFloat(o),"second","s",o)}if(0===n.length)return"0"+(t.verbose?" milliseconds":"ms");let l=t.colonNotation?":":" ";return"number"==typeof t.unitCount&&(n=n.slice(0,Math.max(t.unitCount,1))),n.join(l)}(e)})`,t,r,W)},rA=(e,t)=>e?t?"error":"warning":"success",rP=(e,t,{reject:r})=>{if(rR(e,r,t),e.failed&&r)throw e;return e},rj=(e,t)=>rq(e)?"asyncGenerator":rV(e)?"generator":rz(e)?"fileUrl":rK(e)?"filePath":r1(e)?"webStream":tz(e,{checkOpen:!1})?"native":g(e)?"uint8Array":r3(e)?"asyncIterable":r4(e)?"iterable":r2(e)?rN({transform:e},t):rH(e)?rM(e,t):"native",rM=(e,t)=>tX(e.transform,{checkOpen:!1})?rk(e,t):r2(e.transform)?rN(e,t):rF(e,t),rk=(e,t)=>(rC(e,t,"Duplex stream"),"duplex"),rN=(e,t)=>(rC(e,t,"web TransformStream"),"webTransform"),rC=({final:e,binary:t,objectMode:r},n,i)=>{rG(e,`${n}.final`,i),rG(t,`${n}.binary`,i),r_(r,`${n}.objectMode`)},rG=(e,t,r)=>{if(void 0!==e)throw TypeError(`The \`${t}\` option can only be defined when using a generator, not a ${r}.`)},rF=({transform:e,final:t,binary:r,objectMode:n},i)=>{if(void 0!==e&&!rW(e))throw TypeError(`The \`${i}.transform\` option must be a generator, a Duplex stream or a web TransformStream.`);if(tX(t,{checkOpen:!1}))throw TypeError(`The \`${i}.final\` option must not be a Duplex stream.`);if(r2(t))throw TypeError(`The \`${i}.final\` option must not be a web TransformStream.`);if(void 0!==t&&!rW(t))throw TypeError(`The \`${i}.final\` option must be a generator.`);return r_(r,`${i}.binary`),r_(n,`${i}.objectMode`),rq(e)||rq(t)?"asyncGenerator":"generator"},r_=(e,t)=>{if(void 0!==e&&"boolean"!=typeof e)throw TypeError(`The \`${t}\` option must use a boolean.`)},rW=e=>rq(e)||rV(e),rq=e=>"[object AsyncGeneratorFunction]"===Object.prototype.toString.call(e),rV=e=>"[object GeneratorFunction]"===Object.prototype.toString.call(e),rH=e=>d(e)&&(void 0!==e.transform||void 0!==e.final),rz=e=>"[object URL]"===Object.prototype.toString.call(e),rY=e=>rz(e)&&"file:"!==e.protocol,rK=e=>d(e)&&1===Object.keys(e).length&&rX(e.file),rX=e=>"string"==typeof e,rQ=(e,t)=>"native"===e&&"string"==typeof t&&!rZ.has(t),rZ=new Set(["ipc","ignore","inherit","overlapped","pipe"]),rJ=e=>"[object ReadableStream]"===Object.prototype.toString.call(e),r0=e=>"[object WritableStream]"===Object.prototype.toString.call(e),r1=e=>rJ(e)||r0(e),r2=e=>rJ(e?.readable)&&r0(e?.writable),r3=e=>r8(e)&&"function"==typeof e[Symbol.asyncIterator],r4=e=>r8(e)&&"function"==typeof e[Symbol.iterator],r8=e=>"object"==typeof e&&null!==e,r9=new Set(["generator","asyncGenerator","duplex","webTransform"]),r6=new Set(["fileUrl","filePath","fileNumber"]),r7=new Set(["fileUrl","filePath"]),r5=new Set([...r7,"webStream","nodeStream"]),ne=new Set(["webTransform","duplex"]),nt={generator:"a generator",asyncGenerator:"an async generator",fileUrl:"a file URL",filePath:"a file path string",fileNumber:"a file descriptor number",webStream:"a web stream",nodeStream:"a Node.js stream",webTransform:"a web TransformStream",duplex:"a Duplex stream",native:"any value",iterable:"an iterable",asyncIterable:"an async iterable",string:"a string",uint8Array:"a Uint8Array"},nr=(e,t,r,n)=>"output"===n?nn(e,t,r):ni(e,t,r),nn=(e,t,r)=>{let n=0!==t&&r[t-1].value.readableObjectMode;return{writableObjectMode:n,readableObjectMode:e??n}},ni=(e,t,r)=>{let n=0===t?!0===e:r[t-1].value.readableObjectMode,i=t!==r.length-1&&(e??n);return{writableObjectMode:n,readableObjectMode:i}},no=(e,t)=>{let r=e.findLast(({type:e})=>r9.has(e));return void 0!==r&&("input"===t?r.value.writableObjectMode:r.value.readableObjectMode)},na=(e,t,r,n)=>[...e.filter(({type:e})=>!r9.has(e)),...ns(e,t,r,n)],ns=(e,t,r,{encoding:n})=>{let i=e.filter(({type:e})=>r9.has(e)),o=Array.from({length:i.length});for(let[e,a]of Object.entries(i))o[e]=nl({stdioItem:a,index:Number(e),newTransforms:o,optionName:t,direction:r,encoding:n});return np(o,r)},nl=({stdioItem:e,stdioItem:{type:t},index:r,newTransforms:n,optionName:i,direction:o,encoding:a})=>"duplex"===t?nd({stdioItem:e,optionName:i}):"webTransform"===t?nu({stdioItem:e,index:r,newTransforms:n,direction:o}):nc({stdioItem:e,index:r,newTransforms:n,direction:o,encoding:a}),nd=({stdioItem:e,stdioItem:{value:{transform:t,transform:{writableObjectMode:r,readableObjectMode:n},objectMode:i=n}},optionName:o})=>{if(i&&!n)throw TypeError(`The \`${o}.objectMode\` option can only be \`true\` if \`new Duplex({objectMode: true})\` is used.`);if(!i&&n)throw TypeError(`The \`${o}.objectMode\` option cannot be \`false\` if \`new Duplex({objectMode: true})\` is used.`);return{...e,value:{transform:t,writableObjectMode:r,readableObjectMode:n}}},nu=({stdioItem:e,stdioItem:{value:t},index:r,newTransforms:n,direction:i})=>{let{transform:o,objectMode:a}=d(t)?t:{transform:t},{writableObjectMode:s,readableObjectMode:l}=nr(a,r,n,i);return{...e,value:{transform:o,writableObjectMode:s,readableObjectMode:l}}},nc=({stdioItem:e,stdioItem:{value:t},index:r,newTransforms:n,direction:i,encoding:o})=>{let{transform:a,final:s,binary:l=!1,preserveNewlines:u=!1,objectMode:c}=d(t)?t:{transform:t},p=l||tw.has(o),{writableObjectMode:f,readableObjectMode:h}=nr(c,r,n,i);return{...e,value:{transform:a,final:s,binary:p,preserveNewlines:u,writableObjectMode:f,readableObjectMode:h}}},np=(e,t)=>"input"===t?e.reverse():e,nf=(e,t,r)=>{let n=e.map(e=>nh(e,t));if(n.includes("input")&&n.includes("output"))throw TypeError(`The \`${r}\` option must not be an array of both readable and writable values.`);return n.find(Boolean)??nv},nh=({type:e,value:t},r)=>nm[r]??ng[e](t),nm=["input","output","output"],nb=()=>void 0,ny=()=>"input",ng={generator:nb,asyncGenerator:nb,fileUrl:nb,filePath:nb,iterable:ny,asyncIterable:ny,uint8Array:ny,webStream:e=>r0(e)?"output":"input",nodeStream:e=>tK(e,{checkOpen:!1})?tY(e,{checkOpen:!1})?void 0:"input":"output",webTransform:nb,duplex:nb,native(e){let t=nw(e);return void 0!==t?t:tz(e,{checkOpen:!1})?ng.nodeStream(e):void 0}},nw=e=>[0,ee.stdin].includes(e)?"input":[1,2,ee.stdout,ee.stderr].includes(e)?"output":void 0,nv="output",nS=({stdio:e,ipc:t,buffer:r,verbose:n,...i},o)=>{let a=nT(e,i).map((e,t)=>nE(e,t));return o?nD(a,r,n):nO(a,t)},nT=(e,t)=>{if(void 0===e)return eI.map(e=>t[e]);if(nx(t))throw Error(`It's not possible to provide \`stdio\` in combination with one of ${eI.map(e=>`\`${e}\``).join(", ")}`);if("string"==typeof e)return[e,e,e];if(!Array.isArray(e))throw TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof e}\``);return Array.from({length:Math.max(e.length,eI.length)},(t,r)=>e[r])},nx=e=>eI.some(t=>void 0!==e[t]),nE=(e,t)=>Array.isArray(e)?e.map(e=>nE(e,t)):null==e?t>=eI.length?"ignore":"pipe":e,nD=(e,t,r)=>e.map((e,n)=>!t[n]&&0!==n&&"full"!==r[n]&&n$(e)?"ignore":e),n$=e=>"pipe"===e||Array.isArray(e)&&e.every(e=>"pipe"===e),nO=(e,t)=>t&&!e.includes("ipc")?[...e,"ipc"]:e,nI=(e,t="stdin")=>{let{options:r,fileDescriptors:n}=nB.get(e),i=nU(n,t,!0),o=e.stdio[i];if(null===o)throw TypeError(nP(i,t,r,!0));return o},nR=(e,t="stdout")=>{let{options:r,fileDescriptors:n}=nB.get(e),i=nU(n,t,!1),o="all"===i?e.all:e.stdio[i];if(null==o)throw TypeError(nP(i,t,r,!1));return o},nB=new WeakMap,nU=(e,t,r)=>{let n=nL(t,r);return nA(n,t,r,e),n},nL=(e,t)=>{let r=eN(e);if(void 0!==r)return r;let{validOptions:n,defaultValue:i}=t?{validOptions:'"stdin"',defaultValue:"stdin"}:{validOptions:'"stdout", "stderr", "all"',defaultValue:"stdout"};throw TypeError(`"${nk(t)}" must not be "${e}".
It must be ${n} or "fd3", "fd4" (and so on).
It is optional and defaults to "${i}".`)},nA=(e,t,r,n)=>{let i=n[nM(e)];if(void 0===i)throw TypeError(`"${nk(r)}" must not be ${t}. That file descriptor does not exist.
Please set the "stdio" option to ensure that file descriptor exists.`);if("input"===i.direction&&!r)throw TypeError(`"${nk(r)}" must not be ${t}. It must be a readable stream, not writable.`);if("input"!==i.direction&&r)throw TypeError(`"${nk(r)}" must not be ${t}. It must be a writable stream, not readable.`)},nP=(e,t,r,n)=>{if("all"===e&&!r.all)return'The "all" option must be true to use "from: \'all\'".';let{optionName:i,optionValue:o}=nj(e,r);return`The "${i}: ${nN(o)}" option is incompatible with using "${nk(n)}: ${nN(t)}".
Please set this option with "pipe" instead.`},nj=(e,{stdin:t,stdout:r,stderr:n,stdio:i})=>{let o=nM(e);return 0===o&&void 0!==t?{optionName:"stdin",optionValue:t}:1===o&&void 0!==r?{optionName:"stdout",optionValue:r}:2===o&&void 0!==n?{optionName:"stderr",optionValue:n}:{optionName:`stdio[${o}]`,optionValue:i[o]}},nM=e=>"all"===e?1:e,nk=e=>e?"to":"from",nN=e=>"string"==typeof e?`'${e}'`:"number"==typeof e?`${e}`:"Stream",nC=({stdioItem:e,stdioItem:{type:t},isStdioArray:r,fdNumber:n,direction:i,isSync:o})=>r&&"native"===t?o?nG({stdioItem:e,fdNumber:n,direction:i}):nW({stdioItem:e,fdNumber:n}):e,nG=({stdioItem:e,stdioItem:{value:t,optionName:r},fdNumber:n,direction:i})=>{let o=nF({value:t,optionName:r,fdNumber:n,direction:i});if(void 0!==o)return o;if(tz(t,{checkOpen:!1}))throw TypeError(`The \`${r}: Stream\` option cannot both be an array and include a stream with synchronous methods.`);return e},nF=({value:e,optionName:t,fdNumber:r,direction:n})=>{let i=n_(e,r);if(void 0!==i){if("output"===n)return{type:"fileNumber",value:i,optionName:t};if(C.isatty(i))throw TypeError(`The \`${t}: ${nN(e)}\` option is invalid: it cannot be a TTY with synchronous methods.`);return{type:"uint8Array",value:w((0,J.readFileSync)(i)),optionName:t}}},n_=(e,t)=>{if("inherit"===e)return t;if("number"==typeof e)return e;let r=eO.indexOf(e);if(-1!==r)return r},nW=({stdioItem:e,stdioItem:{value:t,optionName:r},fdNumber:n})=>"inherit"===t?{type:"nodeStream",value:nq(n,t,r),optionName:r}:"number"==typeof t?{type:"nodeStream",value:nq(t,t,r),optionName:r}:tz(t,{checkOpen:!1})?{type:"nodeStream",value:t,optionName:r}:e,nq=(e,t,r)=>{let n=eO[e];if(void 0===n)throw TypeError(`The \`${r}: ${t}\` option is invalid: no such standard stream.`);return n},nV=({input:e,inputFile:t},r)=>0===r?[...nH(e),...nY(t)]:[],nH=e=>void 0===e?[]:[{type:nz(e),value:e,optionName:"input"}],nz=e=>{if(tK(e,{checkOpen:!1}))return"nodeStream";if("string"==typeof e)return"string";if(g(e))return"uint8Array";throw Error("The `input` option must be a string, a Uint8Array or a Node.js Readable stream.")},nY=e=>void 0===e?[]:[{...nK(e),optionName:"inputFile"}],nK=e=>{if(rz(e))return{type:"fileUrl",value:e};if(rX(e))return{type:"filePath",value:{file:e}};throw Error("The `inputFile` option must be a file path string or a file URL.")},nX=e=>e.filter((t,r)=>e.every((e,n)=>t.value!==e.value||r>=n||"generator"===t.type||"asyncGenerator"===t.type)),nQ=({stdioItem:{type:e,value:t,optionName:r},direction:n,fileDescriptors:i,isSync:o})=>{let a=nZ(i,e);if(0!==a.length){if(o){nJ({otherStdioItems:a,type:e,value:t,optionName:r,direction:n});return}if(r5.has(e))return n0({otherStdioItems:a,type:e,value:t,optionName:r,direction:n});ne.has(e)&&n2({otherStdioItems:a,type:e,value:t,optionName:r})}},nZ=(e,t)=>e.flatMap(({direction:e,stdioItems:r})=>r.filter(e=>e.type===t).map(t=>({...t,direction:e}))),nJ=({otherStdioItems:e,type:t,value:r,optionName:n,direction:i})=>{r7.has(t)&&n0({otherStdioItems:e,type:t,value:r,optionName:n,direction:i})},n0=({otherStdioItems:e,type:t,value:r,optionName:n,direction:i})=>{let o=e.filter(e=>n1(e,r));if(0!==o.length)return n3(o.find(e=>e.direction!==i),n,t),"output"===i?o[0].stream:void 0},n1=({type:e,value:t},r)=>"filePath"===e?t.path===r.path:"fileUrl"===e?t.href===r.href:t===r,n2=({otherStdioItems:e,type:t,value:r,optionName:n})=>{n3(e.find(({value:{transform:e}})=>e===r.transform),n,t)},n3=(e,t,r)=>{if(void 0!==e)throw TypeError(`The \`${e.optionName}\` and \`${t}\` options must not target ${nt[r]} that is the same.`)},n4=(e,t,r,n)=>{let i=ii({initialFileDescriptors:nS(t,n).map((e,r)=>n8({stdioOption:e,fdNumber:r,options:t,isSync:n})),addProperties:e,options:t,isSync:n});return t.stdio=i.map(({stdioItems:e})=>il(e)),i},n8=({stdioOption:e,fdNumber:t,options:r,isSync:n})=>{let i=eR(t),{stdioItems:o,isStdioArray:a}=n9({stdioOption:e,fdNumber:t,options:r,optionName:i}),s=nf(o,t,i),l=na(o.map(e=>nC({stdioItem:e,isStdioArray:a,fdNumber:t,direction:s,isSync:n})),i,s,r),d=no(l,s);return ir(l,d),{direction:s,objectMode:d,stdioItems:l}},n9=({stdioOption:e,fdNumber:t,options:r,optionName:n})=>{let i=nX([...(Array.isArray(e)?e:[e]).map(e=>n6(e,n)),...nV(r,t)]),o=i.length>1;return n7(i,o,n),ie(i),{stdioItems:i,isStdioArray:o}},n6=(e,t)=>({type:rj(e,t),value:e,optionName:t}),n7=(e,t,r)=>{if(0===e.length)throw TypeError(`The \`${r}\` option must not be an empty array.`);if(t){for(let{value:t,optionName:r}of e)if(n5.has(t))throw Error(`The \`${r}\` option must not include \`${t}\`.`)}},n5=new Set(["ignore","ipc"]),ie=e=>{for(let t of e)it(t)},it=({type:e,value:t,optionName:r})=>{if(rY(t))throw TypeError(`The \`${r}: URL\` option must use the \`file:\` scheme.
For example, you can use the \`pathToFileURL()\` method of the \`url\` core module.`);if(rQ(e,t))throw TypeError(`The \`${r}: { file: '...' }\` option must be used instead of \`${r}: '...'\`.`)},ir=(e,t)=>{if(!t)return;let r=e.find(({type:e})=>r6.has(e));if(void 0!==r)throw TypeError(`The \`${r.optionName}\` option cannot use both files and transforms in objectMode.`)},ii=({initialFileDescriptors:e,addProperties:t,options:r,isSync:n})=>{let i=[];try{for(let o of e)i.push(io({fileDescriptor:o,fileDescriptors:i,addProperties:t,options:r,isSync:n}));return i}catch(e){throw is(i),e}},io=({fileDescriptor:{direction:e,objectMode:t,stdioItems:r},fileDescriptors:n,addProperties:i,options:o,isSync:a})=>{let s=r.map(t=>ia({stdioItem:t,addProperties:i,direction:e,options:o,fileDescriptors:n,isSync:a}));return{direction:e,objectMode:t,stdioItems:s}},ia=({stdioItem:e,addProperties:t,direction:r,options:n,fileDescriptors:i,isSync:o})=>{let a=nQ({stdioItem:e,direction:r,fileDescriptors:i,isSync:o});return void 0!==a?{...e,stream:a}:{...e,...t[r][e.type](e,n)}},is=e=>{for(let{stdioItems:t}of e)for(let{stream:e}of t)void 0===e||e$(e)||e.destroy()},il=e=>{if(e.length>1)return e.some(({value:e})=>"overlapped"===e)?"overlapped":"pipe";let[{type:t,value:r}]=e;return"native"===t?r:"pipe"},id=(e,t)=>n4(ih,e,t,!0),iu=({type:e,optionName:t})=>{ic(t,nt[e])},ic=(e,t)=>{throw TypeError(`The \`${e}\` option cannot be ${t} with synchronous methods.`)},ip={generator(){},asyncGenerator:iu,webStream:iu,nodeStream:iu,webTransform:iu,duplex:iu,asyncIterable:iu,native:({optionName:e,value:t})=>(("ipc"===t||"overlapped"===t)&&ic(e,`"${t}"`),{})},ih={input:{...ip,fileUrl:({value:e})=>({contents:[w((0,J.readFileSync)(e))]}),filePath:({value:{file:e}})=>({contents:[w((0,J.readFileSync)(e))]}),fileNumber:iu,iterable:({value:e})=>({contents:[...e]}),string:({value:e})=>({contents:[e]}),uint8Array:({value:e})=>({contents:[e]})},output:{...ip,fileUrl:({value:e})=>({path:e}),filePath:({value:{file:e}})=>({path:e}),fileNumber:({value:e})=>({path:e}),iterable:iu,string:iu,uint8Array:iu}},im=(e,{stripFinalNewline:t},r)=>ib(t,r)&&void 0!==e&&!Array.isArray(e)?tG(e):e,ib=(e,t)=>"all"===t?e[1]||e[2]:e[t],iy=require("node:stream"),ig=(e,t,r,n)=>e||r?void 0:iS(t,n),iw=(e,t,r)=>r?e.flatMap(e=>iv(e,t)):iv(e,t),iv=(e,t)=>{let{transform:r,final:n}=iS(t,{});return[...r(e),...n()]},iS=(e,t)=>(t.previousChunks="",{transform:iT.bind(void 0,t,e),final:iE.bind(void 0,t)}),iT=function*(e,t,r){if("string"!=typeof r){yield r;return}let{previousChunks:n}=e,i=-1;for(let o=0;o<r.length;o+=1)if("\n"===r[o]){let a=ix(r,o,t,e),s=r.slice(i+1,o+1-a);n.length>0&&(s=iO(n,s),n=""),yield s,i=o}i!==r.length-1&&(n=iO(n,r.slice(i+1))),e.previousChunks=n},ix=(e,t,r,n)=>r?0:(n.isWindowsNewline=0!==t&&"\r"===e[t-1],n.isWindowsNewline?2:1),iE=function*({previousChunks:e}){e.length>0&&(yield e)},iD=({binary:e,preserveNewlines:t,readableObjectMode:r,state:n})=>e||t||r?void 0:{transform:i$.bind(void 0,n)},i$=function*({isWindowsNewline:e=!1},t){let{unixNewline:r,windowsNewline:n,LF:i,concatBytes:o}="string"==typeof t?iI:iR;if(t.at(-1)===i){yield t;return}yield o(t,e?n:r)},iO=(e,t)=>`${e}${t}`,iI={windowsNewline:"\r\n",unixNewline:"\n",LF:"\n",concatBytes:iO},iR={windowsNewline:new Uint8Array([13,10]),unixNewline:new Uint8Array([10]),LF:10,concatBytes:(e,t)=>{let r=new Uint8Array(e.length+t.length);return r.set(e,0),r.set(t,e.length),r}},iB=require("node:buffer"),iU=(e,t)=>e?void 0:iL.bind(void 0,t),iL=function*(e,t){if("string"!=typeof t&&!g(t)&&!iB.Buffer.isBuffer(t))throw TypeError(`The \`${e}\` option's transform must use "objectMode: true" to receive as input: ${typeof t}.`);yield t},iA=(e,t)=>e?iP.bind(void 0,t):ij.bind(void 0,t),iP=function*(e,t){iM(e,t),yield t},ij=function*(e,t){if(iM(e,t),"string"!=typeof t&&!g(t))throw TypeError(`The \`${e}\` option's function must yield a string or an Uint8Array, not ${typeof t}.`);yield t},iM=(e,t)=>{if(null==t)throw TypeError(`The \`${e}\` option's function must not call \`yield ${t}\`.
Instead, \`yield\` should either be called with a value, or not be called at all. For example:
  if (condition) { yield value; }`)},ik=(e,t,r)=>{if(r)return;if(e)return{transform:iN.bind(void 0,new TextEncoder)};let n=new m.StringDecoder(t);return{transform:iC.bind(void 0,n),final:iG.bind(void 0,n)}},iN=function*(e,t){iB.Buffer.isBuffer(t)?yield w(t):"string"==typeof t?yield e.encode(t):yield t},iC=function*(e,t){yield g(t)?e.write(t):t},iG=function*(e){let t=e.end();""!==t&&(yield t)},iF=(0,H.callbackify)(async(e,t,r,n)=>{t.currentIterable=e(...r);try{for await(let e of t.currentIterable)n.push(e)}finally{delete t.currentIterable}}),i_=async function*(e,t,r){if(r===t.length){yield e;return}let{transform:n=iH}=t[r];for await(let i of n(e))yield*i_(i,t,r+1)},iW=async function*(e){for(let[t,{final:r}]of Object.entries(e))yield*iq(r,Number(t),e)},iq=async function*(e,t,r){if(void 0!==e)for await(let n of e())yield*i_(n,r,t+1)},iV=(0,H.callbackify)(async({currentIterable:e},t)=>{if(void 0!==e){await (t?e.throw(t):e.return());return}if(t)throw t}),iH=function*(e){yield e},iz=(e,t,r,n)=>{try{for(let n of e(...t))r.push(n);n()}catch(e){n(e)}},iY=(e,t)=>[...t.flatMap(t=>[...iK(t,e,0)]),...iX(e)],iK=function*(e,t,r){if(r===t.length){yield e;return}let{transform:n=iZ}=t[r];for(let i of n(e))yield*iK(i,t,r+1)},iX=function*(e){for(let[t,{final:r}]of Object.entries(e))yield*iQ(r,Number(t),e)},iQ=function*(e,t,r){if(void 0!==e)for(let n of e())yield*iK(n,r,t+1)},iZ=function*(e){yield e},iJ=({value:e,value:{transform:t,final:r,writableObjectMode:n,readableObjectMode:i},optionName:o},{encoding:a})=>{let s={},l=i1(e,a,o),d=rq(t),u=rq(r),c=d?iF.bind(void 0,i_,s):iz.bind(void 0,iK),p=d||u?iF.bind(void 0,iW,s):iz.bind(void 0,iX),f=d||u?iV.bind(void 0,s):void 0;return{stream:new iy.Transform({writableObjectMode:n,writableHighWaterMark:(0,iy.getDefaultHighWaterMark)(n),readableObjectMode:i,readableHighWaterMark:(0,iy.getDefaultHighWaterMark)(i),transform(e,t,r){c([e,l,0],this,r)},flush(e){p([l],this,e)},destroy:f})}},i0=(e,t,r,n)=>{let i=t.filter(({type:e})=>"generator"===e);for(let{value:t,optionName:o}of n?i.reverse():i)e=iY(i1(t,r,o),e);return e},i1=({transform:e,final:t,binary:r,writableObjectMode:n,readableObjectMode:i,preserveNewlines:o},a,s)=>{let l={};return[{transform:iU(n,s)},ik(r,a,n),ig(r,o,n,l),{transform:e,final:t},{transform:iA(i,s)},iD({binary:r,preserveNewlines:o,readableObjectMode:i,state:l})].filter(Boolean)},i2=(e,t)=>{for(let r of i3(e))i4(e,r,t)},i3=e=>new Set(Object.entries(e).filter(([,{direction:e}])=>"input"===e).map(([e])=>Number(e))),i4=(e,t,r)=>{let{stdioItems:n}=e[t],i=n.filter(({contents:e})=>void 0!==e);if(0===i.length)return;if(0!==t){let[{type:e,optionName:t}]=i;throw TypeError(`Only the \`stdin\` option, not \`${t}\`, can be ${nt[e]} with synchronous methods.`)}let o=i.map(({contents:e})=>e).map(e=>i8(e,n));r.input=$(o)},i8=(e,t)=>{let r=i0(e,t,"utf8",!0);return i9(r),$(r)},i9=e=>{let t=e.find(e=>"string"!=typeof e&&!g(e));if(void 0!==t)throw TypeError(`The \`stdin\` option is invalid: when passing objects as input, a transform must be used to serialize them to strings or Uint8Arrays: ${t}.`)},i6=({stdioItems:e,encoding:t,verboseInfo:{verbose:r},fdNumber:n})=>"all"!==n&&"full"===r[n]&&!tw.has(t)&&i7(n)&&(e.some(({type:e,value:t})=>"native"===e&&i5.has(t))||e.every(({type:e})=>r9.has(e))),i7=e=>1===e||2===e,i5=new Set(["pipe","overlapped"]),oe=async(e,t,r)=>{for await(let n of e)or(t)||on(n,r)},ot=(e,t)=>{for(let r of e)on(r,t)},or=e=>e._readableState.pipes.length>0,on=(e,{verboseId:t})=>{ea(eg("string"==typeof e?e:(0,H.inspect)(e)).replaceAll("	"," ".repeat(oi)),t,"output")},oi=2,oo=({fileDescriptors:e,syncResult:{output:t},options:r,isMaxBuffer:n,verboseInfo:i})=>{if(null===t)return{output:Array.from({length:3})};let o={},a=new Set([]);return{output:t.map((t,s)=>oa({result:t,fileDescriptors:e,fdNumber:s,state:o,outputFiles:a,isMaxBuffer:n,verboseInfo:i},r)),...o}},oa=({result:e,fileDescriptors:t,fdNumber:r,state:n,outputFiles:i,isMaxBuffer:o,verboseInfo:a},{buffer:s,encoding:l,lines:d,stripFinalNewline:u,maxBuffer:c})=>{if(null===e)return;let p=w(rc(e,o,c)),{stdioItems:f,objectMode:h}=t[r],{serializedResult:m,finalResult:b=m}=ol({chunks:os([p],f,l,n),objectMode:h,encoding:l,lines:d,stripFinalNewline:u,fdNumber:r});i6({stdioItems:f,encoding:l,verboseInfo:a,fdNumber:r})&&ot(iw(m,!1,h),a);let y=s[r]?b:void 0;try{return void 0===n.error&&od(m,f,i),y}catch(e){return n.error=e,y}},os=(e,t,r,n)=>{try{return i0(e,t,r,!1)}catch(t){return n.error=t,e}},ol=({chunks:e,objectMode:t,encoding:r,lines:n,stripFinalNewline:i,fdNumber:o})=>{if(t)return{serializedResult:e};if("buffer"===r)return{serializedResult:$(e)};let a=E(e,r);return n[o]?{serializedResult:a,finalResult:iw(a,!i[o],t)}:{serializedResult:a}},od=(e,t,r)=>{for(let{path:n}of t.filter(({type:e})=>r6.has(e))){let t="string"==typeof n?n:n.toString();r.has(t)?(0,J.appendFileSync)(n,e):(r.add(t),(0,J.writeFileSync)(n,e))}},ou=([,e,t],r)=>r.all?void 0===e?t:void 0===t?e:Array.isArray(e)?Array.isArray(t)?[...e,...t]:[...e,im(t,r,"all")]:Array.isArray(t)?[im(e,r,"all"),...t]:g(e)&&g(t)?I([e,t]):`${e}${t}`:void 0,oc=require("node:events"),op=async e=>{let[t,r]=await Promise.allSettled([(0,oc.once)(e,"spawn"),(0,oc.once)(e,"exit")]);return"rejected"===t.status?[]:"rejected"===r.status?of(e):r.value},of=async e=>{try{return await (0,oc.once)(e,"exit")}catch{return of(e)}},oh=async e=>{let[t,r]=await e;if(!om(t,r)&&ob(t,r))throw new eJ;return[t,r]},om=(e,t)=>void 0===e&&void 0===t,ob=(e,t)=>0!==e||null!==t,oy=({error:e,status:t,signal:r,output:n},{maxBuffer:i})=>{let o=og(e,t,r),a=o?.code==="ETIMEDOUT",s=ru(o,n,i);return{resultError:o,exitCode:t,signal:r,timedOut:a,isMaxBuffer:s}},og=(e,t,r)=>void 0!==e?e:ob(t,r)?new eJ:void 0,ow=(e,t,r)=>{let{file:n,commandArguments:i,command:o,escapedCommand:a,startTime:s,verboseInfo:l,options:d,fileDescriptors:u}=ov(e,t,r);return rP(oE({file:n,commandArguments:i,options:d,command:o,escapedCommand:a,verboseInfo:l,fileDescriptors:u,startTime:s}),l,d)},ov=(e,t,r)=>{let{command:n,escapedCommand:i,startTime:o,verboseInfo:a}=eW(e,t,r);try{let s=oS(r),{file:l,commandArguments:d,options:u}=tO(e,t,s);oT(u);let c=id(u,a);return{file:l,commandArguments:d,command:n,escapedCommand:i,startTime:o,verboseInfo:a,options:u,fileDescriptors:c}}catch(e){throw rB(e,o,a),e}},oS=e=>e.node&&!e.ipc?{...e,ipc:!1}:e,oT=({ipc:e,detached:t,cancelSignal:r})=>{e&&ox("ipc: true"),t&&ox("detached: true"),r&&ox("cancelSignal")},ox=e=>{throw TypeError(`The "${e}" option cannot be used with synchronous methods.`)},oE=({file:e,commandArguments:t,options:r,command:n,escapedCommand:i,verboseInfo:o,fileDescriptors:a,startTime:s})=>{let l=oD({file:e,commandArguments:t,options:r,command:n,escapedCommand:i,fileDescriptors:a,startTime:s});if(l.failed)return l;let{resultError:d,exitCode:u,signal:c,timedOut:p,isMaxBuffer:f}=oy(l,r),{output:h,error:m=d}=oo({fileDescriptors:a,syncResult:l,options:r,isMaxBuffer:f,verboseInfo:o});return oO({error:m,exitCode:u,signal:c,timedOut:p,isMaxBuffer:f,stdio:h.map((e,t)=>im(e,r,t)),all:im(ou(h,r),r,"all"),options:r,command:n,escapedCommand:i,startTime:s})},oD=({file:e,commandArguments:t,options:r,command:n,escapedCommand:i,fileDescriptors:o,startTime:a})=>{try{i2(o,r);let n=o$(r);return(0,h.spawnSync)(e,t,n)}catch(e){return rw({error:e,command:n,escapedCommand:i,fileDescriptors:o,options:r,startTime:a,isSync:!0})}},o$=({encoding:e,maxBuffer:t,...r})=>({...r,encoding:"buffer",maxBuffer:rp(t)}),oO=({error:e,exitCode:t,signal:r,timedOut:n,isMaxBuffer:i,stdio:o,all:a,options:s,command:l,escapedCommand:d,startTime:u})=>void 0===e?rg({command:l,escapedCommand:d,stdio:o,all:a,options:s,startTime:u}):rv({error:e,command:l,escapedCommand:d,timedOut:n,isCanceled:!1,isMaxBuffer:i,exitCode:t,signal:r,stdio:o,all:a,options:s,startTime:u,isSync:!0}),oI=({error:e,command:t,escapedCommand:r,fileDescriptors:n,options:i,startTime:o,verboseInfo:a})=>{is(n);let s=new h.ChildProcess;return oR(s,n),Object.assign(s,{readable:oU,writable:oL,duplex:oA}),{subprocess:s,promise:oP(rw({error:e,command:t,escapedCommand:r,fileDescriptors:n,options:i,startTime:o,isSync:!1}),a,i)}},oR=(e,t)=>{let r=oB(),n=oB(),i=oB(),o=Array.from({length:t.length-3},oB),a=oB(),s=[r,n,i,...o];Object.assign(e,{stdin:r,stdout:n,stderr:i,all:a,stdio:s})},oB=()=>{let e=new iy.PassThrough;return e.end(),e},oU=()=>new iy.Readable({read(){}}),oL=()=>new iy.Writable({write(){}}),oA=()=>new iy.Duplex({read(){},write(){}}),oP=async(e,t,r)=>rP(e,t,r),oj=(e,t)=>n4(oN,e,t,!1),oM=({type:e,optionName:t})=>{throw TypeError(`The \`${t}\` option cannot be ${nt[e]}.`)},ok={fileNumber:oM,generator:iJ,asyncGenerator:iJ,nodeStream:({value:e})=>({stream:e}),webTransform:({value:{transform:e,writableObjectMode:t,readableObjectMode:r}})=>({stream:iy.Duplex.fromWeb(e,{objectMode:t||r})}),duplex:({value:{transform:e}})=>({stream:e}),native(){}},oN={input:{...ok,fileUrl:({value:e})=>({stream:(0,J.createReadStream)(e)}),filePath:({value:{file:e}})=>({stream:(0,J.createReadStream)(e)}),webStream:({value:e})=>({stream:iy.Readable.fromWeb(e)}),iterable:({value:e})=>({stream:iy.Readable.from(e)}),asyncIterable:({value:e})=>({stream:iy.Readable.from(e)}),string:({value:e})=>({stream:iy.Readable.from(e)}),uint8Array:({value:e})=>({stream:iy.Readable.from(iB.Buffer.from(e))})},output:{...ok,fileUrl:({value:e})=>({stream:(0,J.createWriteStream)(e)}),filePath:({value:{file:e}})=>({stream:(0,J.createWriteStream)(e)}),webStream:({value:e})=>({stream:iy.Writable.fromWeb(e)}),iterable:oM,asyncIterable:oM,string:oM,uint8Array:oM}},oC=require("node:stream/promises");function oG(e){if(!Array.isArray(e))throw TypeError(`Expected an array, got \`${typeof e}\`.`);for(let t of e)oH(t);let t=e.some(({readableObjectMode:e})=>e),r=oF(e,t),n=new o_({objectMode:t,writableHighWaterMark:r,readableHighWaterMark:r});for(let t of e)n.add(t);return n}let oF=(e,t)=>0===e.length?(0,iy.getDefaultHighWaterMark)(t):Math.max(...e.filter(({readableObjectMode:e})=>e===t).map(({readableHighWaterMark:e})=>e));class o_ extends iy.PassThrough{#a=new Set([]);#s=new Set([]);#l=new Set([]);#d;#u=Symbol("unpipe");#c=new WeakMap;add(e){if(oH(e),this.#a.has(e))return;this.#a.add(e),this.#d??=oW(this,this.#a,this.#u);let t=oz({passThroughStream:this,stream:e,streams:this.#a,ended:this.#s,aborted:this.#l,onFinished:this.#d,unpipeEvent:this.#u});this.#c.set(e,t),e.pipe(this,{end:!1})}async remove(e){if(oH(e),!this.#a.has(e))return!1;let t=this.#c.get(e);return void 0!==t&&(this.#c.delete(e),e.unpipe(this),await t,!0)}}let oW=async(e,t,r)=>{o3(e,o4);let n=new AbortController;try{await Promise.race([oq(e,n),oV(e,t,r,n)])}finally{n.abort(),o3(e,-o4)}},oq=async(e,{signal:t})=>{try{await (0,oC.finished)(e,{signal:t,cleanup:!0})}catch(t){throw oZ(e,t),t}},oV=async(e,t,r,{signal:n})=>{for await(let[i]of(0,oc.on)(e,"unpipe",{signal:n}))t.has(i)&&i.emit(r)},oH=e=>{if("function"!=typeof e?.pipe)throw TypeError(`Expected a readable stream, got: \`${typeof e}\`.`)},oz=async({passThroughStream:e,stream:t,streams:r,ended:n,aborted:i,onFinished:o,unpipeEvent:a})=>{o3(e,o8);let s=new AbortController;try{await Promise.race([oY(o,t,s),oK({passThroughStream:e,stream:t,streams:r,ended:n,aborted:i,controller:s}),oX({stream:t,streams:r,ended:n,aborted:i,unpipeEvent:a,controller:s})])}finally{s.abort(),o3(e,-o8)}r.size>0&&r.size===n.size+i.size&&(0===n.size&&i.size>0?o0(e):oQ(e))},oY=async(e,t,{signal:r})=>{try{await e,r.aborted||o0(t)}catch(e){r.aborted||oZ(t,e)}},oK=async({passThroughStream:e,stream:t,streams:r,ended:n,aborted:i,controller:{signal:o}})=>{try{await (0,oC.finished)(t,{signal:o,cleanup:!0,readable:!0,writable:!1}),r.has(t)&&n.add(t)}catch(n){if(o.aborted||!r.has(t))return;oJ(n)?i.add(t):o1(e,n)}},oX=async({stream:e,streams:t,ended:r,aborted:n,unpipeEvent:i,controller:{signal:o}})=>{if(await (0,oc.once)(e,i,{signal:o}),!e.readable)return(0,oc.once)(o,"abort",{signal:o});t.delete(e),r.delete(e),n.delete(e)},oQ=e=>{e.writable&&e.end()},oZ=(e,t)=>{oJ(t)?o0(e):o1(e,t)},oJ=e=>e?.code==="ERR_STREAM_PREMATURE_CLOSE",o0=e=>{(e.readable||e.writable)&&e.destroy()},o1=(e,t)=>{e.destroyed||(e.once("error",o2),e.destroy(t))},o2=()=>{},o3=(e,t)=>{let r=e.getMaxListeners();0!==r&&r!==Number.POSITIVE_INFINITY&&e.setMaxListeners(r+t)},o4=2,o8=1,o9=(e,t,r)=>{let n=e.getMaxListeners();0!==n&&n!==Number.POSITIVE_INFINITY&&(e.setMaxListeners(n+t),(0,oc.addAbortListener)(r,()=>{e.setMaxListeners(e.getMaxListeners()-t)}))},o6=(e,t)=>{e.pipe(t),o7(e,t),ae(e,t)},o7=async(e,t)=>{if(!(e$(e)||e$(t))){try{await (0,oC.finished)(e,{cleanup:!0,readable:!0,writable:!1})}catch{}o5(t)}},o5=e=>{e.writable&&e.end()},ae=async(e,t)=>{if(!(e$(e)||e$(t))){try{await (0,oC.finished)(t,{cleanup:!0,readable:!1,writable:!0})}catch{}at(e)}},at=e=>{e.readable&&e.destroy()},ar=(e,t,r)=>{let n=new Map;for(let[i,{stdioItems:o,direction:a}]of Object.entries(t)){for(let{stream:t}of o.filter(({type:e})=>r9.has(e)))an(e,t,a,i);for(let{stream:t}of o.filter(({type:e})=>!r9.has(e)))ao({subprocess:e,stream:t,direction:a,fdNumber:i,pipeGroups:n,controller:r})}for(let[e,t]of n.entries())o6(1===t.length?t[0]:oG(t),e)},an=(e,t,r,n)=>{"output"===r?o6(e.stdio[n],t):o6(t,e.stdio[n]);let i=ai[n];void 0!==i&&(e[i]=t),e.stdio[n]=t},ai=["stdin","stdout","stderr"],ao=({subprocess:e,stream:t,direction:r,fdNumber:n,pipeGroups:i,controller:o})=>{if(void 0===t)return;aa(t,o);let[a,s]="output"===r?[t,e.stdio[n]]:[e.stdio[n],t],l=i.get(a)??[];i.set(a,[...l,s])},aa=(e,{signal:t})=>{e$(e)&&o9(e,as,t)},as=2,al=[];al.push("SIGHUP","SIGINT","SIGTERM"),"win32"!==process.platform&&al.push("SIGALRM","SIGABRT","SIGVTALRM","SIGXCPU","SIGXFSZ","SIGUSR2","SIGTRAP","SIGSYS","SIGQUIT","SIGIOT"),"linux"===process.platform&&al.push("SIGIO","SIGPOLL","SIGPWR","SIGSTKFLT");let ad=e=>!!e&&"object"==typeof e&&"function"==typeof e.removeListener&&"function"==typeof e.emit&&"function"==typeof e.reallyExit&&"function"==typeof e.listeners&&"function"==typeof e.kill&&"number"==typeof e.pid&&"function"==typeof e.on,au=Symbol.for("signal-exit emitter"),ac=globalThis,ap=Object.defineProperty.bind(Object);class af{emitted={afterExit:!1,exit:!1};listeners={afterExit:[],exit:[]};count=0;id=Math.random();constructor(){if(ac[au])return ac[au];ap(ac,au,{value:this,writable:!1,enumerable:!1,configurable:!1})}on(e,t){this.listeners[e].push(t)}removeListener(e,t){let r=this.listeners[e],n=r.indexOf(t);-1!==n&&(0===n&&1===r.length?r.length=0:r.splice(n,1))}emit(e,t,r){if(this.emitted[e])return!1;this.emitted[e]=!0;let n=!1;for(let i of this.listeners[e])n=!0===i(t,r)||n;return"exit"===e&&(n=this.emit("afterExit",t,r)||n),n}}class ah{}class am extends ah{onExit(){return()=>{}}load(){}unload(){}}class ab extends ah{#p="win32"===ay.platform?"SIGINT":"SIGHUP";#f=new af;#h;#m;#b;#y={};#g=!1;constructor(e){for(let t of(super(),this.#h=e,this.#y={},al))this.#y[t]=()=>{let r=this.#h.listeners(t),{count:n}=this.#f;if("object"==typeof e.__signal_exit_emitter__&&"number"==typeof e.__signal_exit_emitter__.count&&(n+=e.__signal_exit_emitter__.count),r.length===n){this.unload();let r=this.#f.emit("exit",null,t),n="SIGHUP"===t?this.#p:t;r||e.kill(e.pid,n)}};this.#b=e.reallyExit,this.#m=e.emit}onExit(e,t){if(!ad(this.#h))return()=>{};!1===this.#g&&this.load();let r=t?.alwaysLast?"afterExit":"exit";return this.#f.on(r,e),()=>{this.#f.removeListener(r,e),0===this.#f.listeners.exit.length&&0===this.#f.listeners.afterExit.length&&this.unload()}}load(){if(!this.#g){for(let e of(this.#g=!0,this.#f.count+=1,al))try{let t=this.#y[e];t&&this.#h.on(e,t)}catch(e){}this.#h.emit=(e,...t)=>this.#w(e,...t),this.#h.reallyExit=e=>this.#v(e)}}unload(){this.#g&&(this.#g=!1,al.forEach(e=>{let t=this.#y[e];if(!t)throw Error("Listener not defined for signal: "+e);try{this.#h.removeListener(e,t)}catch(e){}}),this.#h.emit=this.#m,this.#h.reallyExit=this.#b,this.#f.count-=1)}#v(e){return ad(this.#h)?(this.#h.exitCode=e||0,this.#f.emit("exit",this.#h.exitCode,null),this.#b.call(this.#h,this.#h.exitCode)):0}#w(e,...t){let r=this.#m;if(!("exit"===e&&ad(this.#h)))return r.call(this.#h,e,...t);{"number"==typeof t[0]&&(this.#h.exitCode=t[0]);let n=r.call(this.#h,e,...t);return this.#f.emit("exit",this.#h.exitCode,null),n}}}let ay=globalThis.process,{onExit:ag,load:aw,unload:av}=(n=ad(ay)?new ab(ay):new am,{onExit:(e,t)=>n.onExit(e,t),load:()=>n.load(),unload:()=>n.unload()}),aS=(e,{cleanup:t,detached:r},{signal:n})=>{if(!t||r)return;let i=ag(()=>{e.kill()});(0,oc.addAbortListener)(n,()=>{i()})},aT=({source:e,sourcePromise:t,boundOptions:r,createNested:n},...i)=>{let o=em(),{destination:a,destinationStream:s,destinationError:l,from:d,unpipeSignal:u}=ax(r,n,i),{sourceStream:c,sourceError:p}=a$(e,d),{options:f,fileDescriptors:h}=nB.get(e);return{sourcePromise:t,sourceStream:c,sourceOptions:f,sourceError:p,destination:a,destinationStream:s,destinationError:l,unpipeSignal:u,fileDescriptors:h,startTime:o}},ax=(e,t,r)=>{try{let{destination:n,pipeOptions:{from:i,to:o,unpipeSignal:a}={}}=aE(e,t,...r),s=nI(n,o);return{destination:n,destinationStream:s,from:i,unpipeSignal:a}}catch(e){return{destinationError:e}}},aE=(e,t,r,...n)=>{if(Array.isArray(r))return{destination:t(aD,e)(r,...n),pipeOptions:e};if("string"==typeof r||r instanceof URL){if(Object.keys(e).length>0)throw TypeError('Please use .pipe("file", ..., options) or .pipe(execa("file", ..., options)) instead of .pipe(options)("file", ...).');let[i,o,a]=f(r,...n);return{destination:t(aD)(i,o,a),pipeOptions:a}}if(nB.has(r)){if(Object.keys(e).length>0)throw TypeError("Please use .pipe(options)`command` or .pipe($(options)`command`) instead of .pipe(options)($`command`).");return{destination:r,pipeOptions:n[0]}}throw TypeError(`The first argument must be a template string, an options object, or an Execa subprocess: ${r}`)},aD=({options:e})=>({options:{...e,stdin:"pipe",piped:!0}}),a$=(e,t)=>{try{return{sourceStream:nR(e,t)}}catch(e){return{sourceError:e}}},aO=({sourceStream:e,sourceError:t,destinationStream:r,destinationError:n,fileDescriptors:i,sourceOptions:o,startTime:a})=>{let s=aI({sourceStream:e,sourceError:t,destinationStream:r,destinationError:n});if(void 0!==s)throw aR({error:s,fileDescriptors:i,sourceOptions:o,startTime:a})},aI=({sourceStream:e,sourceError:t,destinationStream:r,destinationError:n})=>void 0!==t&&void 0!==n?n:void 0!==n?(at(e),n):void 0!==t?(o5(r),t):void 0,aR=({error:e,fileDescriptors:t,sourceOptions:r,startTime:n})=>rw({error:e,command:aB,escapedCommand:aB,fileDescriptors:t,options:r,startTime:n,isSync:!1}),aB="source.pipe(destination)",aU=async e=>{let[{status:t,reason:r,value:n=r},{status:i,reason:o,value:a=o}]=await e;if(a.pipedFrom.includes(n)||a.pipedFrom.push(n),"rejected"===i)throw a;if("rejected"===t)throw n;return a},aL=(e,t,r)=>{let n=aM.has(t)?aP(e,t):aA(e,t);return o9(e,ak,r.signal),o9(t,aN,r.signal),aj(t),n},aA=(e,t)=>{let r=oG([e]);return o6(r,t),aM.set(t,r),r},aP=(e,t)=>{let r=aM.get(t);return r.add(e),r},aj=async e=>{try{await (0,oC.finished)(e,{cleanup:!0,readable:!1,writable:!0})}catch{}aM.delete(e)},aM=new WeakMap,ak=2,aN=1,aC=(e,t)=>void 0===e?[]:[aG(e,t)],aG=async(e,{sourceStream:t,mergedStream:r,fileDescriptors:n,sourceOptions:i,startTime:o})=>{throw await (0,H.aborted)(e,t),await r.remove(t),aR({error:Error("Pipe canceled by `unpipeSignal` option."),fileDescriptors:n,sourceOptions:i,startTime:o})},aF=(e,...t)=>{if(d(t[0]))return aF.bind(void 0,{...e,boundOptions:{...e.boundOptions,...t[0]}});let{destination:r,...n}=aT(e,...t),i=a_({...n,destination:r});return i.pipe=aF.bind(void 0,{...e,source:r,sourcePromise:i,boundOptions:{}}),i},a_=async({sourcePromise:e,sourceStream:t,sourceOptions:r,sourceError:n,destination:i,destinationStream:o,destinationError:a,unpipeSignal:s,fileDescriptors:l,startTime:d})=>{let u=aW(e,i);aO({sourceStream:t,sourceError:n,destinationStream:o,destinationError:a,fileDescriptors:l,sourceOptions:r,startTime:d});let c=new AbortController;try{let e=aL(t,o,c);return await Promise.race([aU(u),...aC(s,{sourceStream:t,mergedStream:e,sourceOptions:r,fileDescriptors:l,startTime:d})])}finally{c.abort()}},aW=(e,t)=>Promise.allSettled([e,t]),aq=e=>e,aV=()=>void 0,aH=({contents:e})=>e,az=e=>{throw Error(`Streams in object mode are not supported: ${String(e)}`)},aY=e=>e.length;async function aK(e,t){return t5(e,aX,t)}let aX={init:()=>({contents:[]}),convertChunk:{string:aq,buffer:aq,arrayBuffer:aq,dataView:aq,typedArray:aq,others:aq},getSize:()=>1,truncateChunk:aV,addChunk:(e,{contents:t})=>(t.push(e),t),getFinalChunk:aV,finalize:aH};async function aQ(e,t){return t5(e,a9,t)}let aZ=new TextEncoder,aJ=e=>new Uint8Array(e),a0=e=>new Uint8Array(e.buffer,e.byteOffset,e.byteLength),a1=(e,t)=>{if(t<=e.byteLength)return e;let r=new ArrayBuffer(a3(t));return new Uint8Array(r).set(new Uint8Array(e),0),r},a2=(e,t)=>{if(t<=e.maxByteLength)return e.resize(t),e;let r=new ArrayBuffer(t,{maxByteLength:a3(t)});return new Uint8Array(r).set(new Uint8Array(e),0),r},a3=e=>a4**Math.ceil(Math.log(e)/Math.log(a4)),a4=2,a8=()=>"resize"in ArrayBuffer.prototype,a9={init:()=>({contents:new ArrayBuffer(0)}),convertChunk:{string:e=>aZ.encode(e),buffer:aJ,arrayBuffer:aJ,dataView:a0,typedArray:a0,others:az},getSize:aY,truncateChunk:(e,t)=>e.slice(0,t),addChunk:(e,{contents:t,length:r},n)=>{let i=a8()?a2(t,n):a1(t,n);return new Uint8Array(i).set(e,r),i},getFinalChunk:aV,finalize:({contents:e,length:t})=>a8()?e:e.slice(0,t)};async function a6(e,t){return t5(e,a5,t)}let a7=(e,{textDecoder:t})=>t.decode(e,{stream:!0}),a5={init:()=>({contents:"",textDecoder:new TextDecoder}),convertChunk:{string:aq,buffer:a7,arrayBuffer:a7,dataView:a7,typedArray:a7,others:az},getSize:aY,truncateChunk:(e,t)=>e.slice(0,t),addChunk:(e,{contents:t})=>t+e,getFinalChunk:({textDecoder:e})=>{let t=e.decode();return""===t?void 0:t},finalize:aH},se=({subprocessStdout:e,subprocess:t,binary:r,shouldEncode:n,encoding:i,preserveNewlines:o})=>{let a=new AbortController;return st(t,a),si({stream:e,controller:a,binary:r,shouldEncode:!e.readableObjectMode&&n,encoding:i,shouldSplit:!e.readableObjectMode,preserveNewlines:o})},st=async(e,t)=>{try{await e}catch{}finally{t.abort()}},sr=({stream:e,onStreamEnd:t,lines:r,encoding:n,stripFinalNewline:i,allMixed:o})=>{let a=new AbortController;sn(t,a,e);let s=e.readableObjectMode&&!o;return si({stream:e,controller:a,binary:"buffer"===n,shouldEncode:!s,encoding:n,shouldSplit:!s&&r,preserveNewlines:!i})},sn=async(e,t,r)=>{try{await e}catch{r.destroy()}finally{t.abort()}},si=({stream:e,controller:t,binary:r,shouldEncode:n,encoding:i,shouldSplit:o,preserveNewlines:a})=>ss({onStdoutChunk:(0,oc.on)(e,"data",{signal:t.signal,highWaterMark:sa,highWatermark:sa}),controller:t,binary:r,shouldEncode:n,encoding:i,shouldSplit:o,preserveNewlines:a}),so=(0,iy.getDefaultHighWaterMark)(!0),sa=so,ss=async function*({onStdoutChunk:e,controller:t,binary:r,shouldEncode:n,encoding:i,shouldSplit:o,preserveNewlines:a}){let s=sl({binary:r,shouldEncode:n,encoding:i,shouldSplit:o,preserveNewlines:a});try{for await(let[t]of e)yield*iK(t,s,0)}catch(e){if(!t.signal.aborted)throw e}finally{yield*iX(s)}},sl=({binary:e,shouldEncode:t,encoding:r,shouldSplit:n,preserveNewlines:i})=>[ik(e,r,!t),ig(e,i,!n,{})].filter(Boolean),sd=async({stream:e,onStreamEnd:t,fdNumber:r,encoding:n,buffer:i,maxBuffer:o,lines:a,allMixed:s,stripFinalNewline:l,verboseInfo:d,streamInfo:{fileDescriptors:u}})=>{if(i6({stdioItems:u[r]?.stdioItems,encoding:n,verboseInfo:d,fdNumber:r})&&oe(sr({stream:e,onStreamEnd:t,lines:!0,encoding:n,stripFinalNewline:!0,allMixed:s}),e,d),!i){await su(e);return}let c=sr({stream:e,onStreamEnd:t,lines:a,encoding:n,stripFinalNewline:ib(l,r),allMixed:s});return sc({stream:e,iterable:c,fdNumber:r,encoding:n,maxBuffer:o,lines:a})},su=async e=>{await (0,eQ.setImmediate)(),null===e.readableFlowing&&e.resume()},sc=async({stream:e,stream:{readableObjectMode:t},iterable:r,fdNumber:n,encoding:i,maxBuffer:o,lines:a})=>{try{if(t||a)return await aK(r,{maxBuffer:o});if("buffer"===i)return new Uint8Array(await aQ(r,{maxBuffer:o}));return await a6(r,{maxBuffer:o})}catch(r){return sf(ra({error:r,stream:e,readableObjectMode:t,lines:a,encoding:i,fdNumber:n}))}},sp=async e=>{try{return await e}catch(e){return sf(e)}},sf=({bufferedData:e})=>y(e)?new Uint8Array(e):e,sh=async(e,t,r,{isSameDirection:n,stopOnExit:i=!1}={})=>{let o=sm(e,r),a=new AbortController;try{await Promise.race([...i?[r.exitPromise]:[],(0,oC.finished)(e,{cleanup:!0,signal:a.signal})])}catch(e){o.stdinCleanedUp||sg(e,t,r,n)}finally{a.abort()}},sm=(e,{originalStreams:[t],subprocess:r})=>{let n={stdinCleanedUp:!1};return e===t&&sb(e,r,n),n},sb=(e,t,r)=>{let{_destroy:n}=e;e._destroy=(...i)=>{sy(t,r),n.call(e,...i)}},sy=({exitCode:e,signalCode:t},r)=>{(null!==e||null!==t)&&(r.stdinCleanedUp=!0)},sg=(e,t,r,n)=>{if(!sw(e,t,r,n))throw e},sw=(e,t,r,n=!0)=>r.propagating?sT(e)||sS(e):(r.propagating=!0,sv(r,t)===n?sT(e):sS(e)),sv=({fileDescriptors:e},t)=>"all"!==t&&"input"===e[t].direction,sS=e=>e?.code==="ERR_STREAM_PREMATURE_CLOSE",sT=e=>e?.code==="EPIPE",sx=({subprocess:e,encoding:t,buffer:r,maxBuffer:n,lines:i,stripFinalNewline:o,verboseInfo:a,streamInfo:s})=>e.stdio.map((e,l)=>sE({stream:e,fdNumber:l,encoding:t,buffer:r[l],maxBuffer:n[l],lines:i[l],allMixed:!1,stripFinalNewline:o,verboseInfo:a,streamInfo:s})),sE=async({stream:e,fdNumber:t,encoding:r,buffer:n,maxBuffer:i,lines:o,allMixed:a,stripFinalNewline:s,verboseInfo:l,streamInfo:d})=>{if(!e)return;let u=sh(e,t,d);if(sv(d,t)){await u;return}let[c]=await Promise.all([sd({stream:e,onStreamEnd:u,fdNumber:t,encoding:r,buffer:n,maxBuffer:i,lines:o,allMixed:a,stripFinalNewline:s,verboseInfo:l,streamInfo:d}),u]);return c},sD=({stdout:e,stderr:t},{all:r})=>r&&(e||t)?oG([e,t].filter(Boolean)):void 0,s$=({subprocess:e,encoding:t,buffer:r,maxBuffer:n,lines:i,stripFinalNewline:o,verboseInfo:a,streamInfo:s})=>sE({...sO(e,r),fdNumber:"all",encoding:t,maxBuffer:n[1]+n[2],lines:i[1]||i[2],allMixed:sI(e),stripFinalNewline:o,verboseInfo:a,streamInfo:s}),sO=({stdout:e,stderr:t,all:r},[,n,i])=>{let o=n||i;return o?n?i?{stream:r,buffer:o}:{stream:e,buffer:o}:{stream:t,buffer:o}:{stream:r,buffer:o}},sI=({all:e,stdout:t,stderr:r})=>e&&t&&r&&t.readableObjectMode!==r.readableObjectMode,sR=async({subprocess:e,options:{encoding:t,buffer:r,maxBuffer:n,lines:i,timeoutDuration:o,stripFinalNewline:a},context:s,verboseInfo:l,fileDescriptors:d,originalStreams:u,onInternalError:c,controller:p})=>{let f=op(e),h={originalStreams:u,fileDescriptors:d,subprocess:e,exitPromise:f,propagating:!1},m=sx({subprocess:e,encoding:t,buffer:r,maxBuffer:n,lines:i,stripFinalNewline:a,verboseInfo:l,streamInfo:h}),b=s$({subprocess:e,encoding:t,buffer:r,maxBuffer:n,lines:i,stripFinalNewline:a,verboseInfo:l,streamInfo:h}),y=sB(u,e,h),g=sU(d,h);try{return await Promise.race([Promise.all([{},oh(f),Promise.all(m),b,...y,...g]),c,sL(e,p),...th(e,o,s,p)])}catch(e){return Promise.all([{error:e},f,Promise.all(m.map(e=>sp(e))),sp(b),Promise.allSettled(y),Promise.allSettled(g)])}},sB=(e,t,r)=>e.map((e,n)=>e===t.stdio[n]?void 0:sh(e,n,r)),sU=(e,t)=>e.flatMap(({stdioItems:e},r)=>e.filter(({value:e,stream:t=e})=>tz(t,{checkOpen:!1})&&!e$(t)).map(({type:e,value:n,stream:i=n})=>sh(i,r,t,{isSameDirection:r9.has(e),stopOnExit:"native"===e}))),sL=async(e,{signal:t})=>{let[r]=await (0,oc.once)(e,"error",{signal:t});throw r},sA=()=>{let e={};return Object.assign(new Promise((t,r)=>{Object.assign(e,{resolve:t,reject:r})}),e)},sP=()=>({readableDestroy:new WeakMap,writableFinal:new WeakMap,writableDestroy:new WeakMap}),sj=(e,t,r)=>{let n=e[r];n.has(t)||n.set(t,[]);let i=n.get(t),o=sA();return i.push(o),{resolve:o.resolve.bind(o),promises:i}},sM=async({resolve:e,promises:t},r)=>{e();let[n]=await Promise.race([Promise.allSettled([!0,r]),Promise.all([!1,...t])]);return!n},sk=async e=>{if(void 0!==e)try{await sC(e)}catch{}},sN=async e=>{if(void 0!==e)try{await sG(e)}catch{}},sC=async e=>{await (0,oC.finished)(e,{cleanup:!0,readable:!1,writable:!0})},sG=async e=>{await (0,oC.finished)(e,{cleanup:!0,readable:!0,writable:!1})},sF=async(e,t)=>{if(await e,t)throw t},s_=(e,t,r)=>{r&&!sS(r)?e.destroy(r):t&&e.destroy()},sW=({subprocess:e,concurrentStreams:t,encoding:r},{from:n,binary:i=!0,preserveNewlines:o=!0}={})=>{let a=i||tw.has(r),{subprocessStdout:s,waitReadableDestroy:l}=sq(e,n,t),{readableEncoding:d,readableObjectMode:u,readableHighWaterMark:c}=sV(s,a),{read:p,onStdoutDataDone:f}=sH({subprocessStdout:s,subprocess:e,binary:a,encoding:r,preserveNewlines:o}),h=new iy.Readable({read:p,destroy:(0,H.callbackify)(sK.bind(void 0,{subprocessStdout:s,subprocess:e,waitReadableDestroy:l})),highWaterMark:c,objectMode:u,encoding:d});return sY({subprocessStdout:s,onStdoutDataDone:f,readable:h,subprocess:e}),h},sq=(e,t,r)=>{let n=nR(e,t),i=sj(r,n,"readableDestroy");return{subprocessStdout:n,waitReadableDestroy:i}},sV=({readableEncoding:e,readableObjectMode:t,readableHighWaterMark:r},n)=>n?{readableEncoding:e,readableObjectMode:t,readableHighWaterMark:r}:{readableEncoding:e,readableObjectMode:!0,readableHighWaterMark:so},sH=({subprocessStdout:e,subprocess:t,binary:r,encoding:n,preserveNewlines:i})=>{let o=sA(),a=se({subprocessStdout:e,subprocess:t,binary:r,shouldEncode:!r,encoding:n,preserveNewlines:i});return{read(){sz(this,a,o)},onStdoutDataDone:o}},sz=async(e,t,r)=>{try{let{value:n,done:i}=await t.next();i?r.resolve():e.push(n)}catch{}},sY=async({subprocessStdout:e,onStdoutDataDone:t,readable:r,subprocess:n,subprocessStdin:i})=>{try{await sG(e),await n,await sk(i),await t,r.readable&&r.push(null)}catch(e){await sk(i),sX(r,e)}},sK=async({subprocessStdout:e,subprocess:t,waitReadableDestroy:r},n)=>{await sM(r,t)&&(sX(e,n),await sF(t,n))},sX=(e,t)=>{s_(e,e.readable,t)},sQ=({subprocess:e,concurrentStreams:t},{to:r}={})=>{let{subprocessStdin:n,waitWritableFinal:i,waitWritableDestroy:o}=sZ(e,r,t),a=new iy.Writable({...sJ(n,e,i),destroy:(0,H.callbackify)(s3.bind(void 0,{subprocessStdin:n,subprocess:e,waitWritableFinal:i,waitWritableDestroy:o})),highWaterMark:n.writableHighWaterMark,objectMode:n.writableObjectMode});return s2(n,a),a},sZ=(e,t,r)=>{let n=nI(e,t),i=sj(r,n,"writableFinal"),o=sj(r,n,"writableDestroy");return{subprocessStdin:n,waitWritableFinal:i,waitWritableDestroy:o}},sJ=(e,t,r)=>({write:s0.bind(void 0,e),final:(0,H.callbackify)(s1.bind(void 0,e,t,r))}),s0=(e,t,r,n)=>{e.write(t,r)?n():e.once("drain",n)},s1=async(e,t,r)=>{await sM(r,t)&&(e.writable&&e.end(),await t)},s2=async(e,t,r)=>{try{await sC(e),t.writable&&t.end()}catch(e){await sN(r),s4(t,e)}},s3=async({subprocessStdin:e,subprocess:t,waitWritableFinal:r,waitWritableDestroy:n},i)=>{await sM(r,t),await sM(n,t)&&(s4(e,i),await sF(t,i))},s4=(e,t)=>{s_(e,e.writable,t)},s8=({subprocess:e,concurrentStreams:t,encoding:r},{from:n,to:i,binary:o=!0,preserveNewlines:a=!0}={})=>{let s=o||tw.has(r),{subprocessStdout:l,waitReadableDestroy:d}=sq(e,n,t),{subprocessStdin:u,waitWritableFinal:c,waitWritableDestroy:p}=sZ(e,i,t),{readableEncoding:f,readableObjectMode:h,readableHighWaterMark:m}=sV(l,s),{read:b,onStdoutDataDone:y}=sH({subprocessStdout:l,subprocess:e,binary:s,encoding:r,preserveNewlines:a}),g=new iy.Duplex({read:b,...sJ(u,e,c),destroy:(0,H.callbackify)(s9.bind(void 0,{subprocessStdout:l,subprocessStdin:u,subprocess:e,waitReadableDestroy:d,waitWritableFinal:c,waitWritableDestroy:p})),readableHighWaterMark:m,writableHighWaterMark:u.writableHighWaterMark,readableObjectMode:h,writableObjectMode:u.writableObjectMode,encoding:f});return sY({subprocessStdout:l,onStdoutDataDone:y,readable:g,subprocess:e,subprocessStdin:u}),s2(u,g,l),g},s9=async({subprocessStdout:e,subprocessStdin:t,subprocess:r,waitReadableDestroy:n,waitWritableFinal:i,waitWritableDestroy:o},a)=>{await Promise.all([sK({subprocessStdout:e,subprocess:r,waitReadableDestroy:n},a),s3({subprocessStdin:t,subprocess:r,waitWritableFinal:i,waitWritableDestroy:o},a)])},s6=(e,t,{from:r,binary:n=!1,preserveNewlines:i=!1}={})=>{let o=n||tw.has(t),a=nR(e,r);return s7(se({subprocessStdout:a,subprocess:e,binary:o,shouldEncode:!0,encoding:t,preserveNewlines:i}),a,e)},s7=async function*(e,t,r){try{yield*e}finally{t.readable&&t.destroy(),await r}},s5=(e,{encoding:t})=>{let r=sP();e.readable=sW.bind(void 0,{subprocess:e,concurrentStreams:r,encoding:t}),e.writable=sQ.bind(void 0,{subprocess:e,concurrentStreams:r}),e.duplex=s8.bind(void 0,{subprocess:e,concurrentStreams:r,encoding:t}),e.iterable=s6.bind(void 0,e,t),e[Symbol.asyncIterator]=s6.bind(void 0,e,t,{})},le=(e,t)=>{for(let[r,n]of lr){let i=n.value.bind(t);Reflect.defineProperty(e,r,{...n,value:i})}},lt=(async()=>{})().constructor.prototype,lr=["then","catch","finally"].map(e=>[e,Reflect.getOwnPropertyDescriptor(lt,e)]),ln=(e,t,r,n)=>{let{file:i,commandArguments:o,command:a,escapedCommand:s,startTime:l,verboseInfo:d,options:u,fileDescriptors:c}=li(e,t,r),{subprocess:p,promise:f}=la({file:i,commandArguments:o,options:u,startTime:l,verboseInfo:d,command:a,escapedCommand:s,fileDescriptors:c});return p.pipe=aF.bind(void 0,{source:p,sourcePromise:f,boundOptions:{},createNested:n}),le(p,f),nB.set(p,{options:u,fileDescriptors:c}),p},li=(e,t,r)=>{let{command:n,escapedCommand:i,startTime:o,verboseInfo:a}=eW(e,t,r);try{let{file:s,commandArguments:l,options:d}=tO(e,t,r),u=lo(d),c=oj(u,a);return{file:s,commandArguments:l,command:n,escapedCommand:i,startTime:o,verboseInfo:a,options:u,fileDescriptors:c}}catch(e){throw rB(e,o,a),e}},lo=({timeout:e,signal:t,cancelSignal:r,...n})=>{if(void 0!==t)throw TypeError('The "signal" option has been renamed to "cancelSignal" instead.');return{...n,timeoutDuration:e,signal:r}},la=({file:e,commandArguments:t,options:r,startTime:n,verboseInfo:i,command:o,escapedCommand:a,fileDescriptors:s})=>{let l;try{l=(0,h.spawn)(e,t,r)}catch(e){return oI({error:e,command:o,escapedCommand:a,fileDescriptors:s,options:r,startTime:n,verboseInfo:i})}let d=new AbortController;(0,oc.setMaxListeners)(Number.POSITIVE_INFINITY,d.signal);let u=[...l.stdio];ar(l,s,d),aS(l,r,d);let c=sA();l.kill=tl.bind(void 0,{kill:l.kill.bind(l),options:r,onInternalError:c,controller:d}),l.all=sD(l,r),s5(l,r);let p=ls({subprocess:l,options:r,startTime:n,verboseInfo:i,fileDescriptors:s,originalStreams:u,command:o,escapedCommand:a,onInternalError:c,controller:d});return{subprocess:l,promise:p}},ls=async({subprocess:e,options:t,startTime:r,verboseInfo:n,fileDescriptors:i,originalStreams:o,command:a,escapedCommand:s,onInternalError:l,controller:d})=>{let u={timedOut:!1},[c,[p,f],h,m]=await sR({subprocess:e,options:t,context:u,verboseInfo:n,fileDescriptors:i,originalStreams:o,onInternalError:l,controller:d});return d.abort(),l.resolve(),rP(ll({errorInfo:c,exitCode:p,signal:f,stdio:h.map((e,r)=>im(e,t,r)),all:im(m,t,"all"),context:u,options:t,command:a,escapedCommand:s,startTime:r}),n,t)},ll=({errorInfo:e,exitCode:t,signal:r,stdio:n,all:i,context:o,options:a,command:s,escapedCommand:l,startTime:d})=>"error"in e?rv({error:e.error,command:s,escapedCommand:l,timedOut:o.timedOut,isCanceled:a.signal?.aborted===!0,isMaxBuffer:e.error instanceof ro,exitCode:t,signal:r,stdio:n,all:i,options:a,startTime:d,isSync:!1}):rg({command:s,escapedCommand:l,stdio:n,all:i,options:a,startTime:d}),ld=(e,t)=>{let r=Object.fromEntries(Object.entries(t).map(([t,r])=>[t,lu(t,e[t],r)]));return{...e,...r}},lu=(e,t,r)=>lc.has(e)&&d(t)&&d(r)?{...t,...r}:r,lc=new Set(["env",...e_]),lp=(e,t,r,n)=>{let i=(e,t,n)=>lp(e,t,r,n),o=(...o)=>lf({mapArguments:e,deepOptions:r,boundOptions:t,setBoundExeca:n,createNested:i},...o);return void 0!==n&&n(o,i,t),o},lf=({mapArguments:e,deepOptions:t={},boundOptions:r={},setBoundExeca:n,createNested:i},o,...a)=>{if(d(o))return i(e,ld(r,o),n);let{file:s,commandArguments:l,options:u,isSync:c}=lh({mapArguments:e,firstArgument:o,nextArguments:a,deepOptions:t,boundOptions:r});return c?ow(s,l,u):ln(s,l,u,i)},lh=({mapArguments:e,firstArgument:t,nextArguments:r,deepOptions:n,boundOptions:i})=>{let[o,a,s]=f(...B(t)?U(t,r):[t,...r]),l=ld(ld(n,i),s),{file:d=o,commandArguments:u=a,options:c=l,isSync:p=!1}=e({file:o,commandArguments:a,options:l});return{file:d,commandArguments:u,options:c,isSync:p}},lm=(e,t)=>{if(t.length>0)throw TypeError(`The command and its arguments must be passed as a single string: ${e} ${t}.`);let r=[];for(let t of e.trim().split(lb)){let e=r.at(-1);e&&e.endsWith("\\")?r[r.length-1]=`${e.slice(0,-1)} ${t}`:r.push(t)}let[n,...i]=r;return{file:n,commandArguments:i}},lb=/ +/g,ly=({options:e})=>({...lg(e),isSync:!0}),lg=e=>({options:{...lw(e),...e}}),lw=({input:e,inputFile:t,stdio:r})=>void 0===e&&void 0===t&&void 0===r?{stdin:"inherit"}:{},lv=lp(()=>({}));async function lS(){try{await lv("marp",["--theme","./public/files/css/dakken_style.css","--html","--pdf","./public/files/new.md","-o","./public/files/new.pdf"],{timeout:500})}catch(e){return l.NextResponse.json({error:"failed to convert to pdf file"},{status:500})}return l.NextResponse.json({message:"complete to convert to pdf file"},{status:200})}lp(()=>({isSync:!0})),lp(({file:e,commandArguments:t})=>lm(e,t)),lp(({file:e,commandArguments:t})=>({...lm(e,t),isSync:!0})),lp(({options:e})=>{if(!1===e.node)throw TypeError('The "node" option cannot be false with `execaNode()`.');return{options:{...e,node:!0}}}),lp(({options:e})=>lg(e),{},{preferLocal:!0},(e,t,r)=>{e.sync=t(ly,r),e.s=e.sync});let lT=new o.AppRouteRouteModule({definition:{kind:a.x.APP_ROUTE,page:"/api/convertPDF/route",pathname:"/api/convertPDF",filename:"route",bundlePath:"app/api/convertPDF/route"},resolvedPagePath:"C:\\Users\\sohtn\\Desktop\\dakken_mtg_slide_maker\\src\\app\\api\\convertPDF\\route.ts",nextConfigOutput:"",userland:i}),{requestAsyncStorage:lx,staticGenerationAsyncStorage:lE,serverHooks:lD}=lT,l$="/api/convertPDF/route";function lO(){return(0,s.patchFetch)({serverHooks:lD,staticGenerationAsyncStorage:lE})}},6916:(e,t,r)=>{"use strict";let n=r(2081),i=r(6806),o=r(6213);function a(e,t,r){let a=i(e,t,r),s=n.spawn(a.command,a.args,a.options);return o.hookChildProcess(s,a),s}e.exports=a,e.exports.spawn=a,e.exports.sync=function(e,t,r){let a=i(e,t,r),s=n.spawnSync(a.command,a.args,a.options);return s.error=s.error||o.verifyENOENTSync(s.status,a),s},e.exports._parse=i,e.exports._enoent=o},6213:e=>{"use strict";let t="win32"===process.platform;function r(e,t){return Object.assign(Error(`${t} ${e.command} ENOENT`),{code:"ENOENT",errno:"ENOENT",syscall:`${t} ${e.command}`,path:e.command,spawnargs:e.args})}function n(e,n){return t&&1===e&&!n.file?r(n.original,"spawn"):null}e.exports={hookChildProcess:function(e,r){if(!t)return;let i=e.emit;e.emit=function(t,o){if("exit"===t){let t=n(o,r,"spawn");if(t)return i.call(e,"error",t)}return i.apply(e,arguments)}},verifyENOENT:n,verifyENOENTSync:function(e,n){return t&&1===e&&!n.file?r(n.original,"spawnSync"):null},notFoundError:r}},6806:(e,t,r)=>{"use strict";let n=r(1017),i=r(7677),o=r(4917),a=r(8426),s="win32"===process.platform,l=/\.(?:com|exe)$/i,d=/node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;e.exports=function(e,t,r){t&&!Array.isArray(t)&&(r=t,t=null);let u={command:e,args:t=t?t.slice(0):[],options:r=Object.assign({},r),file:void 0,original:{command:e,args:t}};return r.shell?u:function(e){if(!s)return e;let t=function(e){e.file=i(e);let t=e.file&&a(e.file);return t?(e.args.unshift(e.file),e.command=t,i(e)):e.file}(e),r=!l.test(t);if(e.options.forceShell||r){let r=d.test(t);e.command=n.normalize(e.command),e.command=o.command(e.command),e.args=e.args.map(e=>o.argument(e,r));let i=[e.command].concat(e.args).join(" ");e.args=["/d","/s","/c",`"${i}"`],e.command=process.env.comspec||"cmd.exe",e.options.windowsVerbatimArguments=!0}return e}(u)}},4917:e=>{"use strict";let t=/([()\][%!^"`<>&|;, *?])/g;e.exports.command=function(e){return e=e.replace(t,"^$1")},e.exports.argument=function(e,r){return e=(e=(e=`${e}`).replace(/(\\*)"/g,'$1$1\\"')).replace(/(\\*)$/,"$1$1"),e=(e=`"${e}"`).replace(t,"^$1"),r&&(e=e.replace(t,"^$1")),e}},8426:(e,t,r)=>{"use strict";let n=r(358),i=r(6173);e.exports=function(e){let t;let r=Buffer.alloc(150);try{t=n.openSync(e,"r"),n.readSync(t,r,0,150,0),n.closeSync(t)}catch(e){}return i(r.toString())}},7677:(e,t,r)=>{"use strict";let n=r(1017),i=r(224),o=r(4387);function a(e,t){let r;let a=e.options.env||process.env,s=process.cwd(),l=null!=e.options.cwd,d=l&&void 0!==process.chdir&&!process.chdir.disabled;if(d)try{process.chdir(e.options.cwd)}catch(e){}try{r=i.sync(e.command,{path:a[o({env:a})],pathExt:t?n.delimiter:void 0})}catch(e){}finally{d&&process.chdir(s)}return r&&(r=n.resolve(l?e.options.cwd:"",r)),r}e.exports=function(e){return a(e)||a(e,!0)}},7493:(e,t,r)=>{var n;function i(e,t,r){if("function"==typeof t&&(r=t,t={}),!r){if("function"!=typeof Promise)throw TypeError("callback not provided");return new Promise(function(r,n){i(e,t||{},function(e,t){e?n(e):r(t)})})}n(e,t||{},function(e,n){e&&("EACCES"===e.code||t&&t.ignoreErrors)&&(e=null,n=!1),r(e,n)})}r(358),"win32"===process.platform||global.TESTING_WINDOWS?n=r(492):n=r(4135),e.exports=i,i.sync=function(e,t){try{return n.sync(e,t||{})}catch(e){if(t&&t.ignoreErrors||"EACCES"===e.code)return!1;throw e}}},4135:(e,t,r)=>{e.exports=i,i.sync=function(e,t){return o(n.statSync(e),t)};var n=r(358);function i(e,t,r){n.stat(e,function(e,n){r(e,!e&&o(n,t))})}function o(e,t){var r,n,i,o,a,s,l;return e.isFile()&&(r=e.mode,n=e.uid,i=e.gid,o=void 0!==t.uid?t.uid:process.getuid&&process.getuid(),a=void 0!==t.gid?t.gid:process.getgid&&process.getgid(),s=parseInt("100",8),l=parseInt("010",8),r&parseInt("001",8)||r&l&&i===a||r&s&&n===o||r&(s|l)&&0===o)}},492:(e,t,r)=>{e.exports=o,o.sync=function(e,t){return i(n.statSync(e),e,t)};var n=r(358);function i(e,t,r){return!!(e.isSymbolicLink()||e.isFile())&&function(e,t){var r=void 0!==t.pathExt?t.pathExt:process.env.PATHEXT;if(!r||-1!==(r=r.split(";")).indexOf(""))return!0;for(var n=0;n<r.length;n++){var i=r[n].toLowerCase();if(i&&e.substr(-i.length).toLowerCase()===i)return!0}return!1}(t,r)}function o(e,t,r){n.stat(e,function(n,o){r(n,!n&&i(o,e,t))})}},4387:e=>{"use strict";let t=(e={})=>{let t=e.env||process.env;return"win32"!==(e.platform||process.platform)?"PATH":Object.keys(t).reverse().find(e=>"PATH"===e.toUpperCase())||"Path"};e.exports=t,e.exports.default=t},6173:(e,t,r)=>{"use strict";let n=r(9877);e.exports=(e="")=>{let t=e.match(n);if(!t)return null;let[r,i]=t[0].replace(/#! ?/,"").split(" "),o=r.split("/").pop();return"env"===o?i:i?`${o} ${i}`:o}},9877:e=>{"use strict";e.exports=/^#!(.*)/},224:(e,t,r)=>{let n="win32"===process.platform||"cygwin"===process.env.OSTYPE||"msys"===process.env.OSTYPE,i=r(1017),o=n?";":":",a=r(7493),s=e=>Object.assign(Error(`not found: ${e}`),{code:"ENOENT"}),l=(e,t)=>{let r=t.colon||o,i=e.match(/\//)||n&&e.match(/\\/)?[""]:[...n?[process.cwd()]:[],...(t.path||process.env.PATH||"").split(r)],a=n?t.pathExt||process.env.PATHEXT||".EXE;.CMD;.BAT;.COM":"",s=n?a.split(r):[""];return n&&-1!==e.indexOf(".")&&""!==s[0]&&s.unshift(""),{pathEnv:i,pathExt:s,pathExtExe:a}},d=(e,t,r)=>{"function"==typeof t&&(r=t,t={}),t||(t={});let{pathEnv:n,pathExt:o,pathExtExe:d}=l(e,t),u=[],c=r=>new Promise((o,a)=>{if(r===n.length)return t.all&&u.length?o(u):a(s(e));let l=n[r],d=/^".*"$/.test(l)?l.slice(1,-1):l,c=i.join(d,e);o(p(!d&&/^\.[\\\/]/.test(e)?e.slice(0,2)+c:c,r,0))}),p=(e,r,n)=>new Promise((i,s)=>{if(n===o.length)return i(c(r+1));let l=o[n];a(e+l,{pathExt:d},(o,a)=>{if(!o&&a){if(!t.all)return i(e+l);u.push(e+l)}return i(p(e,r,n+1))})});return r?c(0).then(e=>r(null,e),r):c(0)};e.exports=d,d.sync=(e,t)=>{let{pathEnv:r,pathExt:n,pathExtExe:o}=l(e,t=t||{}),d=[];for(let s=0;s<r.length;s++){let l=r[s],u=/^".*"$/.test(l)?l.slice(1,-1):l,c=i.join(u,e),p=!u&&/^\.[\\\/]/.test(e)?e.slice(0,2)+c:c;for(let e=0;e<n.length;e++){let r=p+n[e];try{if(a.sync(r,{pathExt:o})){if(!t.all)return r;d.push(r)}}catch(e){}}}if(t.all&&d.length)return d;if(t.nothrow)return null;throw s(e)}}};var t=require("../../../webpack-runtime.js");t.C(e);var r=e=>t(t.s=e),n=t.X(0,[948,972],()=>r(2250));module.exports=n})();